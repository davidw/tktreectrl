# Commands covered:  treectrl
#
# This file contains a collection of tests for the treectrl command of
# the tktreectrl extension.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 2000 by Scriptics Corporation.
# Copyright (c) 2002 by Christian Krone.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: treectrl.test,v 1.5 2002/12/27 11:52:16 krischan Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import ::tcltest::*
}

package require Tk
# This works only, if tktreectrl is already installed:
#   package require treectrl
# And we want to test the currently built version anyway.
# So we better load and source it by hand:
set thisPlatform $tcl_platform(platform)
if {![catch {tk windowingsystem} windowingSystem] \
	&& [string equal aqua $windowingSystem]} {
    set thisPlatform macosx
}
switch -- $thisPlatform {
    macintosh {
	load treectrl.shlb
    }
    macosx {
	load build/treectrl.dylib
    }
    unix {
	load [glob libtreectrl*[info sharedlibextension]]
    }
    default { # Windows
	load Build/treectrl[info sharedlibextension]
    }
}

load   [file join . libtreectrl1.0.so]
source [file join library treectrl.tcl]
source [file join library filelist-bindings.tcl]

test tree-1.1 {Usage} -body {
    treectrl
} -returnCodes error -result {wrong # args: should be "treectrl pathName ?options?"}

test tree-1.2 {Unknown option} -body {
    treectrl .t -foo bar
} -returnCodes error -result {unknown option "-foo"}

test tree-1.3 {Create a tree} -body {
    treectrl .t
} -result {.t}

test tree-1.4 {configure: List all options} -body {
    .t configure
} -result {{-background background Background white white} {-backgroundmode backgroundMode BackgroundMode row row} {-bd -borderwidth} {-bg -background} {-borderwidth borderWidth BorderWidth 2 2} {-buttoncolor buttonColor ButtonColor #808080 #808080} {-buttonsize buttonSize ButtonSize 9 9} {-buttonthickness buttonThickness ButtonThickness 1 1} {-closedbuttonbitmap closedButtonBitmap ClosedButtonBitmap {} {}} {-closedbuttonimage closedButtonImage ClosedButtonImage {} {}} {-columnproxy columnProxy ColumnProxy {} {}} {-cursor cursor Cursor {} {}} {-doublebuffer doubleBuffer DoubleBuffer item item} {-fg -foreground} {-font font Font {Helvetica -12 bold} {Helvetica -12 bold}} {-foreground foreground Foreground Black Black} {-height height Height 200 200} {-highlightbackground highlightBackground HighlightBackground #d9d9d9 #d9d9d9} {-highlightcolor highlightColor HighlightColor Black Black} {-highlightthickness highlightThickness HighlightThickness 1 1} {-indent indent Indent 19 19} {-itemheight itemHeight ItemHeight 0 0} {-linecolor lineColor LineColor #808080 #808080} {-linestyle lineStyle LineStyle dot dot} {-linethickness lineThickness LineThickness 1 1} {-openbuttonbitmap openButtonBitmap OpenButtonBitmap {} {}} {-openbuttonimage openButtonImage OpenButtonImage {} {}} {-orient orient Orient vertical vertical} {-relief relief Relief sunken sunken} {-scrollmargin scrollMargin ScrollMargin 0 0} {-selectmode selectMode SelectMode browse browse} {-showbuttons showButtons ShowButtons 1 1} {-showheader showHeader ShowHeader 1 1} {-showlines showLines ShowLines 1 1} {-showroot showRoot ShowRoot 1 1} {-showrootbutton showRootButton ShowRootButton 0 0} {-takefocus takeFocus TakeFocus {} {}} {-treecolumn treeColumn TreeColumn 0 0} {-width width Width 200 200} {-wrap wrap Wrap {} {}} {-xscrollcommand xScrollCommand ScrollCommand {} {}} {-xscrolldelay xScrollDelay ScrollDelay 50 50} {-xscrollincrement xScrollIncrement ScrollIncrement 0 0} {-yscrollcommand yScrollCommand ScrollCommand {} {}} {-yscrolldelay yScrollDelay ScrollDelay 50 50} {-yscrollincrement yScrollIncrement ScrollIncrement 0 0}}

test tree-1.5 {configure -background with totally empty visible tree} -body {
    pack .t
    update idletasks
    .t configure -background white
    update idletasks
} -result {}

test tree-1.6 {configure: -background option} -body {
    .t configure -background yellow
    .t configure -background
} -result {-background background Background white yellow}

test tree-1.7 {configure: invalid -backgroundmode option} -body {
    .t configure -backgroundmode foo
} -returnCodes error -result {bad backgroundmode "foo": must be column, index, row, or visindex}

test tree-1.8 {configure: -backgroundmode option} -body {
    .t configure -backgroundmode column
    .t configure -backgroundmode
} -result {-backgroundmode backgroundMode BackgroundMode row column}

test tree-1.9 {configure: invalid -buttonsize option} -body {
    .t configure -buttonsize foo
} -returnCodes error -result {bad screen distance "foo"}

test tree-1.10 {configure: -buttonsize option} -body {
    .t configure -buttonsize 1c
    .t configure -buttonsize
} -result {-buttonsize buttonSize ButtonSize 9 1c}

test tree-1.11 {configure: invalid -buttoncolor option} -body {
    .t configure -buttoncolor foo
} -returnCodes error -result {unknown color name "foo"}

test tree-1.12 {configure: -buttoncolor option} -body {
    .t configure -buttoncolor red
    .t configure -buttoncolor
} -result {-buttoncolor buttonColor ButtonColor #808080 red}

test tree-1.13 {configure: invalid -openbuttonbitmap option} -body {
    .t configure -openbuttonbitmap foo
} -returnCodes error -result {bitmap "foo" not defined}

test tree-1.14 {configure: -openbuttonbitmap option} -body {
    .t configure -openbuttonbitmap hourglass
    .t configure -openbuttonbitmap
} -result {-openbuttonbitmap openButtonBitmap OpenButtonBitmap {} hourglass}

test tree-1.15 {configure: invalid -closedbuttonbitmap option} -body {
    .t configure -closedbuttonbitmap foo
} -returnCodes error -result {bitmap "foo" not defined}

test tree-1.16 {configure: -closedbuttonbitmap option} -body {
    .t configure -closedbuttonbitmap questhead
    .t configure -closedbuttonbitmap
} -result {-closedbuttonbitmap closedButtonBitmap ClosedButtonBitmap {} questhead}

test tree-1.17 {configure: invalid -openbuttonimage option} -body {
    .t configure -openbuttonimage foo
} -returnCodes error -result {image "foo" doesn't exist}

test tree-1.18 {configure: -openbuttonimage option} -body {
    image create photo emptyImg
    .t configure -openbuttonimage emptyImg
    .t configure -openbuttonimage
} -result {-openbuttonimage openButtonImage OpenButtonImage {} emptyImg}

test tree-1.19 {configure: invalid -closedbuttonimage option} -body {
    .t configure -closedbuttonimage foo
} -returnCodes error -result {image "foo" doesn't exist}

test tree-1.20 {configure: -closedbuttonimage option} -body {
    .t configure -closedbuttonimage emptyImg
    .t configure -closedbuttonimage
} -result {-closedbuttonimage closedButtonImage ClosedButtonImage {} emptyImg}

test tree-1.21 {configure: invalid -doublebuffer option} -body {
    .t configure -doublebuffer foo
} -returnCodes error -result {bad doublebuffer "foo": must be none, item, or window}

test tree-1.22 {configure: -doublebuffer option} -body {
    .t configure -doublebuffer window
    .t configure -doublebuffer
} -result {-doublebuffer doubleBuffer DoubleBuffer item window}

test tree-1.23 {configure: invalid -indent option} -body {
    .t configure -indent foo
} -returnCodes error -result {bad screen distance "foo"}

test tree-1.24 {configure: -indent option} -body {
    .t configure -indent 2c
    .t configure -indent
} -result {-indent indent Indent 19 2c}

test tree-1.25 {configure: invalid -itemheight option} -body {
    .t configure -itemheight foo
} -returnCodes error -result {bad screen distance "foo"}

test tree-1.26 {configure: -itemheight option} -body {
    .t configure -itemheight 18m
    .t configure -itemheight
} -result {-itemheight itemHeight ItemHeight 0 18m}

test tree-1.27 {configure: invalid -linestyle option} -body {
    .t configure -linestyle foo
} -returnCodes error -result {bad linestyle "foo": must be dot or solid}

test tree-1.28 {configure: -linestyle option} -body {
    .t configure -linestyle solid
    .t configure -linestyle
} -result {-linestyle lineStyle LineStyle dot solid}

test tree-1.29 {configure: invalid -linethickness option} -body {
    .t configure -linethickness foo
} -returnCodes error -result {bad screen distance "foo"}

test tree-1.30 {configure: -linethickness option} -body {
    .t configure -linethickness 3m
    .t configure -linethickness
} -result {-linethickness lineThickness LineThickness 1 3m}

test tree-1.31 {configure: invalid -linecolor option} -body {
    .t configure -linecolor #foo
} -returnCodes error -result {invalid color name "#foo"}

test tree-1.32 {configure: -linethickness option} -body {
    .t configure -linecolor gray20
    .t configure -linecolor
} -result {-linecolor lineColor LineColor #808080 gray20}

test tree-1.33 {configure: invalid -orient option} -body {
    .t configure -orient foo
} -returnCodes error -result {bad orient "foo": must be horizontal or vertical}

test tree-1.34 {configure: -orient option} -body {
    .t configure -orient h
    .t configure -orient
} -result {-orient orient Orient vertical horizontal}

test tree-1.35 {configure: invalid -relief option} -body {
    .t configure -relief foo
} -returnCodes error -result {bad relief "foo": must be flat, groove, raised, ridge, solid, or sunken}

test tree-1.36 {configure: -relief option} -body {
    .t configure -relief flat
    .t configure -relief
} -result {-relief relief Relief sunken flat}

test tree-1.37 {configure: invalid -showbuttons option} -body {
    .t configure -showbuttons foo
} -returnCodes error -result {expected boolean value but got "foo"}

test tree-1.38 {configure: -showbuttons option} -body {
    .t configure -showbuttons off
    .t configure -showbuttons
} -result {-showbuttons showButtons ShowButtons 1 0}

test tree-1.39 {configure: invalid -showheader option} -body {
    .t configure -showheader foo
} -returnCodes error -result {expected boolean value but got "foo"}

test tree-1.40 {configure: -showheader option} -body {
    .t configure -showheader off
    .t configure -showheader
} -result {-showheader showHeader ShowHeader 1 0}

test tree-1.41 {configure: invalid -showlines option} -body {
    .t configure -showlines foo
} -returnCodes error -result {expected boolean value but got "foo"}

test tree-1.42 {configure: -showlines option} -body {
    .t configure -showlines false
    .t configure -showlines
} -result {-showlines showLines ShowLines 1 0}

test tree-1.43 {configure: invalid -showroot option} -body {
    .t configure -showroot foo
} -returnCodes error -result {expected boolean value but got "foo"}

test tree-1.44 {configure: -showroot option} -body {
    .t configure -showroot no
    .t configure -showroot
} -result {-showroot showRoot ShowRoot 1 0}

test tree-1.45 {configure: invalid -showrootbutton option} -body {
    .t configure -showrootbutton foo
} -returnCodes error -result {expected boolean value but got "foo"}

test tree-1.46 {configure: -showrootbutton option} -body {
    .t configure -showrootbutton True
    .t configure -showrootbutton
} -result {-showrootbutton showRootButton ShowRootButton 0 1}

test tree-1.47 {configure: invalid -treecolumn option} -body {
    .t configure -treecolumn foo
} -returnCodes error -result {expected integer but got "foo"}

test tree-1.48 {configure: -treecolumn option with unknown column} -body {
    .t configure -treecolumn 1
    .t configure -treecolumn
} -result {-treecolumn treeColumn TreeColumn 0 1}

test tree-1.49 {configure: -treecolumn option with known column} -body {
    .t column configure 0 -tag column0
    .t column configure 1 -tag column1
    .t configure -treecolumn 1
    .t configure -treecolumn
} -result {-treecolumn treeColumn TreeColumn 0 1}

test tree-1.50 {configure: invalid -wrap mode} -body {
    .t configure -wrap foo
} -returnCodes error -result {bad wrap "foo"}

test tree-1.51 {configure: invalid -wrap option: bogus width} -body {
    .t configure -wrap {item bar}
} -returnCodes error -result {bad wrap "item bar"}

test tree-1.52 {configure: invalid -wrap option: superflous width} -body {
    .t configure -wrap {1 window}
} -returnCodes error -result {bad wrap "1 window"}

test tree-1.53 {configure: -wrap option} -body {
    .t configure -wrap {7 items}
    .t configure -wrap
} -result {-wrap wrap Wrap {} {7 items}}

test tree-1.54 {configure: -wrap empty option} -body {
    .t configure -wrap {}
    .t configure -wrap
} -result {-wrap wrap Wrap {} {}}

# For the tests of the item descriptions we use see,
# if we want to generate an error on unknown items.
# For the positive cases we use index since it returns the item number.

test tree-2.1 {bogus itemdesc} -body {
    .t index foo
} -returnCodes error -result {bad item description "foo"}

test tree-2.2 {is all allowed?} -body {
    .t index all
} -returnCodes error -result {can't specify "all" for this command}

test tree-2.3 {itemdesc number unknown} -body {
    .t see 999
} -returnCodes error -result {item "999" doesn't exist}

test tree-2.4 {itemdesc number of root} -body {
    .t index 0
} -result {0}

test tree-2.5 {itemdesc active} -body {
    .t index active
} -result {0}

test tree-2.6 {itemdesc abbreviated anchor} -body {
    .t index an
} -result {0}

test tree-2.7 {itemdesc first} -body {
    .t index first
} -result {0}

test tree-2.8 {itemdesc first visible} -body {
    .t configure -showroot 1
    .t index "first visible"
} -result {0}

test tree-2.9 {itemdesc first visible without any node} -body {
    .t configure -showroot 0
    .t see "first visible"
} -returnCodes error -result {item "first visible" doesn't exist}

test tree-2.10 {itemdesc last} -body {
    .t index last
} -result {0}

test tree-2.11 {itemdesc last visible} -body {
    .t configure -showroot 1
    .t index "last visible"
} -result {0}

test tree-2.12 {itemdesc last visible without any node} -body {
    .t configure -showroot 0
    .t see "last visible"
} -returnCodes error -result {item "last visible" doesn't exist}

test tree-2.13 {itemdesc nearest without x/y} -body {
    .t index nearest
} -returnCodes error -result {bad item description "nearest"}

test tree-2.14 {itemdesc nearest with invalid x/y} -body {
    .t index "nearest foo bar"
} -returnCodes error -result {bad item description "nearest foo bar"}

test tree-2.15 {itemdesc nearest with valid x/y, but no item} -body {
    .t configure -showroot 0
    .t index "nearest 10 10"
} -result {}

# Before continuing to test the item descriptions and their modifiers,
# lets create some items with this hierarchy:
# 0
# + 1
# | + 2
# | + 3
# |   + 4
# + 5
# | + 6
# | + 7
# + 8
test tree-2.16 {create some items} -body {
    set n1 [.t item create]; .t item lastchild 0   $n1
    set n2 [.t item create]; .t item lastchild $n1 $n2
    set n3 [.t item create]; .t item lastchild $n1 $n3
    set n4 [.t item create]; .t item lastchild $n3 $n4
    set n5 [.t item create]; .t item lastchild 0   $n5
    set n6 [.t item create]; .t item lastchild $n5 $n6
    set n7 [.t item create]; .t item lastchild $n5 $n7
    set n8 [.t item create]; .t item lastchild 0   $n8
} -result {8}

test tree-2.17 {itemdesc nearest with valid x/y} -body {
    # I think this should return an item, but it doesn't...
    .t index "nearest 10 10"
} -result {}

test tree-2.18 {itemdesc rnc without r/c} -body {
    .t index rnc
} -returnCodes error -result {bad item description "rnc"}

test tree-2.19 {itemdesc rnc with invalid r/c} -body {
    .t index "rnc foo bar"
} -returnCodes error -result {bad item description "rnc foo bar"}

test tree-2.20 {itemdesc rnc with valid r/c} -body {
    .t index "rnc 0 0"
} -result {1}

test tree-2.21 {itemdesc root} -body {
    .t configure -showroot 1 -orient vertical
    .t index root
} -result {0}

test tree-2.22 {bogus modifier} -body {
    .t index "0 foo"
} -returnCodes error -result {bad modifier "foo": must be above, below, bottom, child, firstchild, lastchild, left, leftmost, next, nextsibling, parent, prev, prevsibling, right, rightmost, sibling, top, or visible}

test tree-2.23 {valid modifier with too less arguments} -body {
    .t index "0 child"
} -returnCodes error -result {bad item description "0 child"}

test tree-2.24 {modifier visible alone generates an error} -body {
    .t index "0 visible"
} -returnCodes error -result {bad item description "0 visible"}

test tree-2.25 {modifier above} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n above"]
    }
    set res
} -result {{} 0 1 2 3 4 5 6 7}

test tree-2.26 {modifier below} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n below"]
    }
    set res
} -result {1 2 3 4 5 6 7 8 {}}

test tree-2.27 {modifier bottom} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n bottom"]
    }
    set res
} -result {8 8 8 8 8 8 8 8 8}

test tree-2.28 {modifier child} -body {
    set res {}
    for {set n 0} {$n < 6} {incr n} {
	for {set c 0} {$c < 3} {incr c} {
	    lappend res [.t index "$n child $c"]
	}
    }
    set res
} -result {1 5 8 2 3 {} {} {} {} 4 {} {} {} {} {} 6 7 {}}

test tree-2.29 {modifier firstchild} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n firstchild"]
    }
    set res
} -result {1 2 {} 4 {} 6 {} {} {}}

test tree-2.30 {modifier lastchild} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n lastchild"]
    }
    set res
} -result {8 3 {} 4 {} 7 {} {} {}}

test tree-2.30 {modifier left, leftmost, right, and rightmost} -body {
    list [.t index "1 left"] [.t index "1 right"] \
	 [.t index "2 leftmost"] [.t index "3 rightmost"]
} -result {{} {} 2 3}

test tree-2.31 {modifier next} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n next"]
    }
    set res
} -result {1 2 3 4 5 6 7 8 {}}

test tree-2.32 {modifier nextsibling} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n nextsibling"]
    }
    set res
} -result {{} 5 3 {} {} 8 7 {} {}}

test tree-2.33 {modifier parent} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n parent"]
    }
    set res
} -result {{} 0 1 1 3 0 5 5 0}

test tree-2.34 {modifier prev} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n prev"]
    }
    set res
} -result {{} 0 1 2 3 4 5 6 7}

test tree-2.34 {modifier prevsibling} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n prevsibling"]
    }
    set res
} -result {{} {} {} 2 {} 1 {} 6 5}

test tree-2.35 {modifier sibling} -body {
    set res {}
    for {set n 0} {$n < 7} {incr n} {
	for {set c 0} {$c < 3} {incr c} {
	    lappend res [.t index "$n sibling $c"]
	}
    }
    set res
} -result {{} {} {} 1 5 8 2 3 {} 2 3 {} 4 {} {} 1 5 8 6 7 {}}

test tree-2.36 {modifier top} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n top"]
    }
    set res
} -result {0 0 0 0 0 0 0 0 0}

test tree-2.37 {modifier cocktail} -body {
    set res {}
    set itemDesc 7
    foreach mod {
	bottom rightmost sibling 0 nextsibling prev parent
	prevsibling prev nextsibling lastchild next
    } {
	lappend itemDesc $mod
	catch {lappend res [.t index $itemDesc]}
    }
    set res
} -result {8 8 1 5 4 3 2 1 5 7 8}

test tree-3.1 {element: missing op} -body {
    .t element
} -returnCodes error -result {wrong # args: should be ".t element command ?arg arg...?"}

test tree-3.2 {element create: missing argument} -body {
    .t element create
} -returnCodes error -result {wrong # args: should be ".t element create name type ?option value...?"}

test tree-3.3 {element create: unknown type} -body {
    .t element create foo bar
} -returnCodes error -result {unknown element type "bar"}

test tree-3.4 {element create: a bitmap} -body {
    .t element create eBitmap bitmap
} -result {eBitmap}

test tree-3.5 {element configure: for a bitmap} -body {
    .t element configure eBitmap
} -result {{-background {} {} {} {}} {-bitmap {} {} {} {}} {-foreground {} {} {} {}}}

test tree-3.6 {element configure: bitmap invalid -background} -body {
    .t element configure eBitmap -background blur
} -returnCodes error -result {unknown color name "blur"}

test tree-3.7 {element configure/cget: bitmap -background} -body {
    .t element configure eBitmap -background blue
    .t element cget eBitmap -background
} -result {blue}

test tree-3.8 {element configure: bitmap invalid psd -background} -body {
    .t element configure eBitmap -background {blue !selected blur {}}
} -returnCodes error -result {unknown color name "blur"}

test tree-3.9 {element configure/cget: bitmap psd -background} -body {
    .t element configure eBitmap -background {blue open magenta {}}
    .t element cget eBitmap -background
} -result {blue open magenta {}}

test tree-3.10 {element configure/cget: bitmap invalid -bitmap} -body {
    .t element configure eBitmap -bitmap notExists
} -returnCodes error -result {bitmap "notExists" not defined}

test tree-3.11 {element configure/cget: bitmap -bitmap} -body {
    .t element configure eBitmap -bitmap questhead
    .t element cget eBitmap -bitmap
} -result {questhead}

test tree-3.12 {element configure: bitmap invalid psd -bitmap} -body {
    .t element configure eBitmap -bitmap {questhead selected yep {}}
} -returnCodes error -result {bitmap "yep" not defined}

test tree-3.13 {element configure/cget: bitmap psd -background} -body {
    .t element configure eBitmap -bitmap {questhead !open error {}}
    .t element cget eBitmap -bitmap
} -result {questhead !open error {}}

test tree-3.14 {element configure: bitmap invalid -foreground} -body {
    .t element configure eBitmap -foreground foobar
} -returnCodes error -result {unknown color name "foobar"}

test tree-3.15 {element configure/cget: bitmap -foreground} -body {
    .t element configure eBitmap -foreground yellow
    .t element cget eBitmap -foreground
} -result {yellow}

test tree-3.16 {element configure: bitmap invalid psd -foreground} -body {
    .t element configure eBitmap -foreground {blue ! red {}}
} -returnCodes error -result {unknown state ""}

test tree-3.17 {element configure/cget: bitmap psd -foreground} -body {
    .t element configure eBitmap -foreground {blue open red !selected}
    .t element cget eBitmap -foreground
} -result {blue open red !selected}

test tree-3.18 {element create: a border} -body {
    .t element create eBorder border
} -result {eBorder}

test tree-3.19 {element configure: for a border} -body {
    .t element configure eBorder
} -result {{-background {} {} {} {}} {-filled {} {} {} {}} {-height {} {} {} {}} {-relief {} {} {} {}} {-thickness {} {} {} {}} {-width {} {} {} {}}}

test tree-3.20 {element configure: border invalid -background} -body {
    .t element configure eBorder -background #
} -returnCodes error -result {invalid color name "#"}

test tree-3.21 {element configure/cget: border -background} -body {
    .t element configure eBorder -background #010101
    .t element cget eBorder -background
} -result {#010101}

test tree-3.22 {element configure: border invalid psd -background} -body {
    .t element configure eBorder -background {blue active red !}
} -returnCodes error -result {unknown state ""}

test tree-3.23 {element configure/cget: border psd -background} -body {
    .t element configure eBorder -background {blue !open red selected}
    .t element cget eBorder -background
} -result {blue !open red selected}

test tree-3.24 {element configure: border invalid -filled} -body {
    .t element configure eBorder -filled foo
} -returnCodes error -result {expected boolean value but got "foo"}

test tree-3.25 {element configure/cget: border -filled} -body {
    .t element configure eBorder -filled 1
    .t element cget eBorder -filled
} -result {1}

test tree-3.26 {element configure: border invalid -height} -body {
    .t element configure eBorder -height {200 300}
} -returnCodes error -result {bad screen distance "200 300"}

test tree-3.27 {element configure/cget: border -height} -body {
    .t element configure eBorder -height 200
    .t element cget eBorder -height
} -result {200}

test tree-3.28 {element configure: border invalid -relief} -body {
    .t element configure eBorder -relief groovy
} -returnCodes error -result {bad relief "groovy": must be flat, groove, raised, ridge, solid, or sunken}

test tree-3.29 {element configure/cget: border -relief} -body {
    .t element configure eBorder -relief ridge
    .t element cget eBorder -relief
} -result {ridge}

test tree-3.30 {element configure: border invalid psd -relief} -body {
    .t element configure eBorder -relief {groove open ridge}
} -returnCodes error -result {list must have event number of elements}

test tree-3.31 {element configure/cget: border psd -relief} -body {
    .t element configure eBorder -relief {groove !open ridge {}}
    .t element cget eBorder -relief
} -result {groove !open ridge {}}

test tree-3.32 {element configure: border invalid -thickness} -body {
    .t element configure eBorder -thickness jup
} -returnCodes error -result {bad screen distance "jup"}

test tree-3.33 {element configure/cget: border -thickness} -body {
    .t element configure eBorder -thickness 8
    .t element cget eBorder -thickness
} -result {8}

test tree-3.34 {element configure: border invalid -width} -body {
    .t element configure eBorder -width {300 200}
} -returnCodes error -result {bad screen distance "300 200"}

test tree-3.35 {element configure/cget: border -width} -body {
    .t element configure eBorder -width 300
    .t element cget eBorder -width
} -result {300}

test tree-3.36 {element create: an image} -body {
    .t element create eImage image
} -result {eImage}

test tree-3.37 {element configure: for an image} -body {
    .t element configure eImage
} -result {{-height {} {} {} {}} {-image {} {} {} {}} {-width {} {} {} {}}}

test tree-3.38 {element configure: image invalid -height} -body {
    .t element configure eImage -height {101 open 200 {}}
} -returnCodes error -result {bad screen distance "101 open 200 {}"}

test tree-3.39 {element configure/cget: image -height} -body {
    .t element configure eImage -height 101
    .t element cget eImage -height
} -result {101}

test tree-3.40 {element configure: image unknown -image} -body {
    .t element configure eImage -image foo
} -returnCodes error -result {image "foo" doesn't exist}

test tree-3.41 {element configure/cget: image -image} -body {
    .t element configure eImage -image emptyImg
    .t element cget eImage -image
} -result {emptyImg}

test tree-3.42 {element configure: image invalid psd -image} -body {
    .t element configure eImage -image {emptyImg open dirImg}
} -returnCodes error -result {list must have event number of elements}

test tree-3.43 {element configure/cget: image psd -image} -body {
    .t element configure eImage -image {emptyImg {}}
    .t element cget eImage -image
} -result {emptyImg {}}

test tree-3.44 {element configure: image invalid -width} -body {
    .t element configure eImage -width {202 boo}
} -returnCodes error -result {bad screen distance "202 boo"}

test tree-3.45 {element configure/cget: image -width} -body {
    .t element configure eImage -width 202
    .t element cget eImage -width
} -result {202}

test tree-3.46 {element create: a rectangle} -body {
    .t element create eRect rect
} -result {eRect}

test tree-3.47 {element configure: for a rectangle} -body {
    .t element configure eRect
} -result {{-fill {} {} {} {}} {-height {} {} {} {}} {-open {} {} {} {}} {-outline {} {} {} {}} {-outlinewidth {} {} {} {}} {-showfocus {} {} {} {}} {-width {} {} {} {}}}

test tree-3.48 {element configure: rectangle invalid -fill} -body {
    .t element configure eRect -fill baz
} -returnCodes error -result {unknown color name "baz"}

test tree-3.49 {element configure/cget: rectangle -fill} -body {
    .t element configure eRect -fill blue
    .t element cget eRect -fill
} -result {blue}

test tree-3.50 {element configure: rectangle invalid psd -fill} -body {
    .t element configure eRect -fill {red blue yellow green}
} -returnCodes error -result {unknown state "blue"}

test tree-3.51 {element configure/cget: rectangle psd -fill} -body {
    .t element configure eRect -fill {red open blue {}}
    .t element cget eRect -fill
} -result {red open blue {}}

test tree-3.52 {element configure: rectangle invalid -height} -body {
    .t element configure eRect -height 100b
} -returnCodes error -result {bad screen distance "100b"}

test tree-3.53 {element configure/cget: rectangle -height} -body {
    .t element configure eRect -height 200
    .t element cget eRect -height
} -result {200}

test tree-3.54 {element configure: rectangle invalid -open} -body {
    .t element configure eRect -open now
} -returnCodes error -result {bad open value "now": must be a string containing zero or more of n, e, s, and w}

test tree-3.55 {element configure/cget: rectangle -open} -body {
    .t element configure eRect -open n
    .t element cget eRect -open
} -result {n}

test tree-3.56 {element configure: rectangle invalid -outline} -body {
    .t element configure eRect -outline baz
} -returnCodes error -result {unknown color name "baz"}

test tree-3.57 {element configure/cget: rectangle -outline} -body {
    .t element configure eRect -outline blue
    .t element cget eRect -outline
} -result {blue}

test tree-3.58 {element configure: rectangle invalid psd -outline} -body {
    .t element configure eRect -outline {red blue yellow green}
} -returnCodes error -result {unknown state "blue"}

test tree-3.59 {element configure/cget: rectangle psd -outline} -body {
    .t element configure eRect -outline {red {} blue open}
    .t element cget eRect -outline
} -result {red {} blue open}

test tree-3.60 {element configure: rectangle invalid -outlinewidth} -body {
    .t element configure eRect -outlinewidth baz
} -returnCodes error -result {bad screen distance "baz"}

test tree-3.61 {element configure/cget: rectangle -outlinewidth} -body {
    .t element configure eRect -outlinewidth 1c
    .t element cget eRect -outlinewidth
} -result {1c}

test tree-3.62 {element configure: rectangle invalid -showfocus} -body {
    .t element configure eRect -showfocus baz
} -returnCodes error -result {expected boolean value but got "baz"}

test tree-3.63 {element configure/cget: rectangle -showfocus} -body {
    .t element configure eRect -showfocus 1
    .t element cget eRect -showfocus
} -result {1}

test tree-3.64 {element configure: rectangle invalid -width} -body {
    .t element configure eRect -width baz
} -returnCodes error -result {bad screen distance "baz"}

test tree-3.65 {element configure/cget: rectangle -width} -body {
    .t element configure eRect -width 10c
    .t element cget eRect -width
} -result {10c}

test tree-3.66 {element create: a text} -body {
    .t element create eText text
} -result {eText}

test tree-3.67 {element configure: for a text} -body {
    .t element configure eText
} -result {{-data {} {} {} {}} {-datatype {} {} {} {}} {-format {} {} {} {}} {-fill {} {} {} {}} {-font {} {} {} {}} {-justify {} {} {} {}} {-lines {} {} {} {}} {-text {} {} {} {}} {-width {} {} {} {}} {-wrap {} {} {} {}}}

test tree-3.68 {element configure/cget: text -data} -body {
    .t element configure eText -data "1.23456789"
    .t element cget eText -data
} -result {1.23456789}

test tree-3.69 {element configure: text invalid -datatype} -body {
    .t element configure eText -datatype float
} -returnCodes error -result {bad datatype "float": must be double, integer, long, string, or time}

test tree-3.70 {element configure/cget: text -datatype} -body {
    .t element configure eText -datatype double
    .t element cget eText -datatype
} -result {double}

test tree-3.71 {element configure: text invalid -fill} -body {
    .t element configure eText -fill baz
} -returnCodes error -result {unknown color name "baz"}

test tree-3.72 {element configure/cget: text -fill} -body {
    .t element configure eText -fill blue
    .t element cget eText -fill
} -result {blue}

test tree-3.73 {element configure: text invalid psd -fill} -body {
    .t element configure eText -fill {red blue yellow green}
} -returnCodes error -result {unknown state "blue"}

test tree-3.74 {element configure/cget: text psd -fill} -body {
    .t element configure eText -fill {red open blue {}}
    .t element cget eText -fill
} -result {red open blue {}}

test tree-3.75 {element configure/cget: text -format} -body {
    .t element configure eText -format "The value of the double is a secret"
    .t element cget eText -format
} -result {The value of the double is a secret}

test tree-3.76 {element configure: text invalid -font} -body {
    # Invalid font doesn't generate an error...
    .t element configure eText -font {"Australia 12"}
   .t element cget eText -font
} -result {"Australia 12"}

test tree-3.77 {element configure/cget: text -font} -body {
    .t element configure eText -font {"Helvetica 12"}
    .t element cget eText -font
} -result {"Helvetica 12"}

test tree-3.78 {element configure: text invalid psd -font} -body {
    .t element configure eText -font {"Australia 12" opened}
} -returnCodes error -result {unknown state "opened"}

test tree-3.79 {element configure/cget: text -font} -body {
    .t element configure eText -font {"Helvetica 12" open "Times 18" {}}
    .t element cget eText -font
} -result {"Helvetica 12" open "Times 18" {}}

test tree-3.80 {element configure: text invalid -justify} -body {
    .t element configure eText -justify north
} -returnCodes error -result {bad justification "north": must be left, right, or center}

test tree-3.81 {element configure/cget: text -justify} -body {
    .t element configure eText -justify center
    .t element cget eText -justify
} -result {center}

test tree-3.82 {element configure: text invalid -lines} -body {
    .t element configure eText -lines asap
} -returnCodes error -result {expected integer but got "asap"}

test tree-3.83 {element configure/cget: text -lines} -body {
    .t element configure eText -lines 5
    .t element cget eText -lines
} -result {5}

test tree-3.84 {element configure/cget: text -text} -body {
    .t element configure eText -text "Hallo Welt"
    .t element cget eText -text
} -result {Hallo Welt}

test tree-3.85 {element configure: text invalid -wrap} -body {
    .t element configure eText -wrap none
} -returnCodes error -result {bad wrap "none": must be char or word}

test tree-3.86 {element configure/cget: text -wrap} -body {
    .t element configure eText -wrap char
    .t element cget eText -wrap
} -result {char}

test tree-3.87 {element types} -body {
    set res {}
    foreach e {eBitmap eBorder eImage eRect eText} {
	lappend res [.t element type $e]
    }
    set res
} -result {bitmap border image rect text}

test tree-3.88 {element names} -body {
    lsort [.t element names]
} -result {eBitmap eBorder eImage eRect eText}

test tree-3.89 {element delete with something unknown in middle} -body {
    .t element delete eBitmap eNotExist eBorder
} -returnCodes error -result {element "eNotExist" doesn't exist}

test tree-3.90 {element names} -body {
    lsort [.t element names]
} -result {eBorder eImage eRect eText}

# Disabled since it triggers a panic() in Range_ItemUnderPoint()
test tree-3.91 {element delete while item is still displayed} -constraints knownBug -body {
    .t element create elText text -text hallo
    .t style create stText
    .t style element stText elText
    set new [.t item create]
    .t item style set $new 0 stText
    .t item lastchild 0 $new
    .t element delete elText
    place [frame .obscure] -in .t -relwidth 1.0 -relheight 1.0
    update
    destroy .obscure
    update
} -result {}

test tree-4.1 {style: missing args} -body {
    .t style
} -returnCodes error -result {wrong # args: should be ".t style command ?arg arg...?"}

test tree-4.2 {style: invalid command} -body {
    .t style foo
} -returnCodes error -result {bad command "foo": must be cget, configure, create, delete, elements, layout, or names}

test tree-4.3 {style names: no style exists yet} -body {
    .t style names
} -result {}

test tree-4.4 {style create: missing args} -body {
    .t style create
} -returnCodes error -result {wrong # args: should be ".t style create name ?option value...?"}

test tree-4.5 {style create: invalid option} -body {
    .t style create testStyle -foo bar
} -returnCodes error -result {unknown option "-foo"}

test tree-4.6 {style create} -body {
    .t style create testStyle
} -result {testStyle}

test tree-4.7 {style create: already existing style} -body {
    .t style create testStyle
} -returnCodes error -result {style "testStyle" already exists}

test tree-4.8 {style configure: invalid option} -body {
    .t style configure testStyle -foo bar
} -returnCodes error -result {unknown option "-foo"}

test tree-4.9 {style configure: all options} -body {
    .t style configure testStyle
} -result {{-orient {} {} horizontal horizontal}}

test tree-4.10 {style configure: the only option} -body {
    .t style configure testStyle -orient
} -result {-orient {} {} horizontal horizontal}

test tree-4.11 {style configure: invalid option -orient} -body {
    .t style configure testStyle -orient diagonal
} -returnCodes error -result {bad orient "diagonal": must be horizontal or vertical}

test tree-4.12 {style configure/cget: option -orient} -body {
    .t style configure testStyle -orient vertical
    .t style cget testStyle -orient
} -result {vertical}

test tree-4.13 {style delete: unknown style} -body {
    .t style delete testStyle2
} -returnCodes error -result {style "testStyle2" doesn't exist}

test tree-4.14 {style delete: unknown style} -body {
    .t style names
} -result {testStyle}

test tree-4.15 {style delete} -body {
    .t style delete testStyle
} -result {}

test tree-4.16 {style names: no style defined} -body {
    .t style names
} -result {}

test tree-4.17 {style elements: missing args} -body {
    .t style elements
} -returnCodes error -result {wrong # args: should be ".t style elements name ?element element...?"}

test tree-4.18 {style elements: unknown style} -body {
    .t style elements testStyle
} -returnCodes error -result {style "testStyle" doesn't exist}

test tree-4.19 {style elements: no element yet} -body {
    .t style create testStyle
    .t style elements testStyle
} -result {}

test tree-4.20 {style elements: empty element list} -body {
    .t style elements testStyle {}
} -result {}

test tree-4.21 {style elements: add some elements} -body {
    .t style elements testStyle {eBorder eImage eText}
    .t style elements testStyle
} -result {eBorder eImage eText}

test tree-4.22 {style layout: missing args} -body {
    .t style layout
} -returnCodes error -result {wrong # args: should be ".t style layout name element ?option? ?value? ?option value ...?"}

test tree-4.23 {style layout: no options specified} -body {
    .t style layout testStyle eText
} -result {-padw 0 -padn 0 -pade 0 -pads 0 -ipadw 0 -ipadn 0 -ipade 0 -ipads 0 -expand {} -iexpand {} -detach no -squeeze {} -union {}}

test tree-4.24 {style layout: option -pads} -body {
    .t style layout testStyle eText -pads 3
    .t style layout testStyle eText -pads
} -result {3}

test tree-4.25 {style layout: option -expand} -body {
    .t style layout testStyle eText -expand "hello world"
    .t style layout testStyle eText -expand
} -result {we}

test tree-4.26 {style layout: option -squeeze} -body {
    .t style layout testStyle eText -squeeze "xyzzy"
    .t style layout testStyle eText -squeeze
} -result {xy}

test tree-4.27 {style layout: option -union invalid list} -body {
    .t style layout testStyle eText -union "\{"
} -returnCodes error -result {unmatched open brace in list}

test tree-4.28 {style layout: option -union unknown elements} -body {
    .t style layout testStyle eText -union {foo bar}
} -returnCodes error -result {element "foo" doesn't exist}

test tree-4.29 {style layout: option -union element not in style} -body {
    .t style layout testStyle eText -union {eBorder eRect}
} -returnCodes error -result {style testStyle does not use element eRect}

test tree-4.30 {style layout: option -union with itself} -body {
    .t style layout testStyle eText -union {eBorder eText}
} -returnCodes error -result {element eText can't form union with itself}

test tree-4.31 {style layout: option -union} -body {
    .t style layout testStyle eText -union {eBorder eImage}
    .t style layout testStyle eText -union
} -result {eBorder eImage}

test tree-4.32 {style layout: option invalid -detach} -body {
    .t style layout testStyle eText -detach {x y}
} -returnCodes error -result {expected boolean value but got "x y"}

test tree-4.33 {style layout: option -detach} -body {
    .t style layout testStyle eText -detach true
    .t style layout testStyle eText -detach
} -result {1}

test tree-5.1 {state: missing args} -body {
    .t state
} -returnCodes error -result {wrong # args: should be ".t state command ?arg arg...?"}

test tree-5.2 {state: invalid command} -body {
    .t state foo
} -returnCodes error -result {bad command "foo": must be define, undefine, or names}

test tree-5.3 {state names: too many args} -body {
    # This should generate an error?
    .t state names foo bar
} -result {}

test tree-5.4 {state names: no states defined yet} -body {
    .t state names
} -result {}

test tree-5.5 {state define: missing args} -body {
    .t state define
} -returnCodes error -result {wrong # args: should be ".t state define stateName"}

test tree-5.6 {state define: overflow check} -body {
    set msg ""
    set ret 0
    for {set ix 0} {$ix < 1000} {incr ix} {
	set ret [catch {.t state define state$ix} msg]
	if {$ret} {break}
    }
    list $ret $ix $msg
} -result {1 27 {cannot define any more states}}

test tree-5.7 {state names} -body {
    .t state names
} -result {state0 state1 state2 state3 state4 state5 state6 state7 state8 state9 state10 state11 state12 state13 state14 state15 state16 state17 state18 state19 state20 state21 state22 state23 state24 state25 state26}

test tree-5.8 {state undefine: missing args} -body {
    .t state undefine
} -returnCodes error -result {wrong # args: should be ".t state undefine stateName"}

test tree-5.9 {state undefine: too many args} -body {
    # too bad that this doesn't work...
    eval {.t state undefine} [lrange [.t state names] 1 end]
} -returnCodes error -result {wrong # args: should be ".t state undefine stateName"}

test tree-5.10 {state undefine: too many args} -body {
    foreach state [lrange [.t state names] 1 end] {
	.t state undefine $state
    }
    .t state names
} -result {state0}

test tree-6.1 {item: missing command} -body {
    .t item
} -returnCodes error -result {wrong # args: should be ".t item command ?arg arg...?"}

test tree-6.2 {item: invalid command} -body {
    .t item foo
} -returnCodes error -result {bad command "foo": must be ancestors, children, create, delete, firstchild, lastchild, nextsibling, numchildren, parent, prevsibling, remove, bbox, complex, dump, element, hasbutton, index, isancestor, isopen, rnc, sort, state, style, text, or visible}

test tree-6.3 {item create: too many args} -body {
    .t item create foo
} -returnCodes error -result {wrong # args: should be ".t item create"}

test tree-6.4 {item create} -body {
    list [.t item create] [.t item create] [.t item create]
} -result {9 10 11}

test tree-6.5 {item delete: missing itemDesc} -body {
    .t item delete
} -returnCodes error -result {wrong # args: should be ".t item delete first ?last?"}

test tree-6.6 {item delete: unknown item} -body {
    .t item delete 999
} -returnCodes error -result {item "999" doesn't exist}

test tree-6.7 {item delete: one item} -body {
    .t item delete 9
} -result {}

test tree-6.8 {item delete: item range without common ancestor} -body {
    .t item delete 10 11
} -returnCodes error -result {item 10 and item 11 don't share a common ancestor}

test tree-6.9 {item delete: item range without common ancestor} -body {
    .t item lastchild 8 10
    .t item lastchild 8 11
    .t item delete 10 11
} -result {}

test tree-6.10 {item ancestors: no ancestor yet} -body {
    .t item create
    .t item ancestors 12
} -result {}

test tree-6.11 {item ancestors} -body {
    .t item lastchild 7 12
    .t item ancestors 12
} -result {7 5 0}

test tree-6.12 {item children: no children} -body {
    .t item children 12
} -result {}

test tree-6.13 {item children} -body {
    .t item children 0
} -result {1 5 8}

test tree-6.14 {item firstchild: missing itemDesc} -body {
    .t item firstchild
} -returnCodes error -result {wrong # args: should be ".t item firstchild item ?newFirstChild?"}

test tree-6.15 {item firstchild: no children} -body {
    .t item firstchild 12
} -result {}

test tree-6.16 {item firstchild} -body {
    .t item firstchild 1
} -result {2}

test tree-6.17 {item lastchild: no children} -body {
    .t item lastchild 1
} -result {3}

test tree-6.18 {item nextsibling: no sibling} -body {
    .t item nextsibling 12
} -result {}

test tree-6.19 {item nextsibling: no sibling} -body {
    .t item nextsibling 2
} -result {3}

test tree-6.20 {item numchildren: no children} -body {
    .t item numchildren 12
} -result {0}

test tree-6.21 {item numchildren} -body {
    .t item numchildren 1
} -result {2}

test tree-6.22 {item parent: no parent} -body {
    .t item parent root
} -result {}

test tree-6.23 {item parent} -body {
    .t item parent "root firstchild"
} -result {0}

test tree-6.24 {item prevsibling: missing arg} -body {
    .t item prevsibling
} -returnCodes error -result {wrong # args: should be ".t item prevsibling item ?newPrevSibling?"}

test tree-6.25 {item prevsibling: no prevsibling} -body {
    .t item prevsibling 1
} -result {}

test tree-6.26 {item prevsibling} -body {
    .t item prevsibling 3
} -result {2}

test tree-6.27 {item remove: invalid item} -body {
    .t item remove 999
} -returnCodes error -result {item "999" doesn't exist}

test tree-6.28 {item remove} -body {
    .t item remove 12
} -result {}

test tree-6.29 {item complex: missing args} -body {
    .t item complex 8
} -returnCodes error -result {wrong # args: should be ".t item complex item list..."}

test tree-6.30 {item complex: only allowed if column style is defined} -body {
    .t item complex 8 {{e1 -text Hallo}}
} -returnCodes error -result {item 8 doesn't have column 0}

test tree-6.31 {item complex: invalid list} -body {
    .t item style set 8 0 testStyle
    .t item complex 8 {{e1 -text}}
} -returnCodes error -result {wrong # args: should be "element option value..."}

test tree-6.32 {item complex: element name not defined in style} -body {
    .t item complex 8 {{e1 -text Hallo}}
} -returnCodes error -result {element "e1" doesn't exist}

test tree-6.33 {item complex: option not known in element} -body {
    .t item complex 8 {{eText -bitmap questhead}}
} -returnCodes error -result {unknown option "-bitmap"}

test tree-6.34 {item complex: invalid option value in element} -body {
    .t item complex 8 {{eText -fill foo}}
} -returnCodes error -result {unknown color name "foo"}

test tree-6.35 {item element: missing command} -body {
    .t item element
} -returnCodes error -result {wrong # args: should be ".t item element command item column element ?arg ...?"}

test tree-6.36 {item element: invalid command} -body {
    .t item element foo 8 0 eText
} -returnCodes error -result {bad command "foo": must be actual, cget, or configure}

test tree-6.37 {item element actual: missing arg} -body {
    .t item element actual 8 0 eText
} -returnCodes error -result {wrong # args: should be ".t item element actual item column element option"}

test tree-6.38 {item element actual} -body {
    .t item element actual 8 0 eText -fill
} -result {red}

test tree-6.39 {item element cget: missing arg} -body {
    .t item element cget 8 0 eText
} -returnCodes error -result {wrong # args: should be ".t item element cget item column element option"}

test tree-6.40 {item element cget} -body {
    .t item element cget 8 0 eText -fill
} -result {}

test tree-6.41 {item element configure} -body {
    .t item element configure 8 0 eText
} -result {{-data {} {} {} {}} {-datatype {} {} {} {}} {-format {} {} {} {}} {-fill {} {} {} {}} {-font {} {} {} {}} {-justify {} {} {} {}} {-lines {} {} {} {}} {-text {} {} {} {}} {-width {} {} {} {}} {-wrap {} {} {} {}}}

test tree-6.42 {item element configure/cget} -body {
    .t item element configure 8 0 eText -fill yellow
    .t item element cget 8 0 eText -fill
} -result {yellow}

test tree-6.43 {item element configure} -body {
    .t item element configure 8 0 eText -fill
} -result {-fill {} {} {} yellow}

test tree-6.44 {item style: missing args} -body {
    .t item style
} -returnCodes error -result {wrong # args: should be ".t item style command item ?arg ...?"}

test tree-6.45 {item style: invalid command} -body {
    .t item style foo bar
} -returnCodes error -result {bad command "foo": must be elements, map, or set}

test tree-6.45 {item style: invalid command} -body {
    .t item style foo bar
} -returnCodes error -result {bad command "foo": must be elements, map, or set}

test tree-6.46 {item style elements: missing args} -body {
    .t item style elements 8
} -returnCodes error -result {wrong # args: should be ".t item style elements item column"}

test tree-6.47 {item style elements: invalid item} -body {
    .t item style elements 999
} -returnCodes error -result {item "999" doesn't exist}

test tree-6.48 {item style elements: item without style} -body {
    .t item style elements 1 0
} -returnCodes error -result {item 1 doesn't have column 0}

test tree-6.49 {item style elements} -body {
    .t item style elements 8 0
} -result {eText}

test tree-6.50 {item style map: missing args} -body {
    .t item style map 8
} -returnCodes error -result {wrong # args: should be ".t item style map item column style map"}

test tree-6.51 {item style map: invalid item} -body {
    .t item style map 999
} -returnCodes error -result {item "999" doesn't exist}

test tree-6.52 {item style map: item with unknown style} -body {
    .t item style map 1 0 noStyle {foo bar}
} -returnCodes error -result {style "noStyle" doesn't exist}

test tree-6.53 {item style map: odd elemented list} -body {
    .t item style map 8 0 testStyle foo
    .t item style elements 8 0
} -returnCodes error -result {list must contain even number of elements}

test tree-6.54 {item style map: unknown element} -body {
    .t style create testStyle2
    .t item style map 8 0 testStyle2 {eText foo}
    .t item style elements 8 0
} -returnCodes error -result {element "foo" doesn't exist}

test tree-6.55 {item style map: element not in to-style} -body {
    .t item style map 8 0 testStyle2 {eText eRect}
} -returnCodes error -result {style testStyle2 does not use element eRect}

test tree-6.56 {item style map: element not in from-style} -body {
    # .t style elements testStyle2 {eImage eRect}
    .t item style map 8 0 testStyle2 {eRect eBorder}
} -returnCodes error -result {style testStyle does not use element eRect}

test tree-6.57 {item style map: different element types} -body {
    .t style elements testStyle2 {eImage eRect}
    .t item style map 8 0 testStyle2 {eBorder eRect}
} -returnCodes error -result {can't map element type border to rect}

test tree-6.58 {item style set: invalid item} -body {
    .t item style set foo bar
} -returnCodes error -result {bad item description "foo"}

test tree-6.59 {item style set: without args returns all styles} -body {
    .t item style set 2
} -result {}

test tree-6.60 {item style set: without args returns style} -body {
    .t item style set 2 0
} -returnCodes error -result {item 2 doesn't have column 0}

test tree-6.61 {item style set: without args returns style} -body {
    .t item style set 8 0
} -result {testStyle}

test tree-6.62 {item style set} -body {
    .t item style set 8 0 testStyle2
    .t item style set 8
} -result {testStyle2}

test tree-6.63 {item state: missing args} -body {
    .t item state
} -returnCodes error -result {wrong # args: should be ".t item state item ?state ...?"}

test tree-6.64 {item state: unknown item} -body {
    .t item state 999
} -returnCodes error -result {item "999" doesn't exist}

test tree-6.65 {item state: list all set states} -body {
    .t item state 8
} -result {open enabled}

test tree-6.66 {item state: try to reset predefined state} -body {
    .t item state 8 !open
} -returnCodes error -result {cannot change state "!open"}

test tree-6.67 {item state: unknown states} -body {
    .t item state 8 foo bar
} -returnCodes error -result {cannot change state "foo"}

test tree-6.68 {item state: switch on states} -body {
    .t item state 8 state0
    .t item state 8
} -result {open enabled state0}

test tree-6.69 {item state: switch off states} -body {
    .t item state 8 !state0
    .t item state 8
} -result {open enabled}

test tree-6.70 {item state: reset predefined state} -body {
    .t collapse 8
    .t item state 8
} -result {enabled}

test tree-6.71 {item state: reset predefined state} -body {
    .t expand 8
    .t item state 8
} -result {open enabled}

test tree-6.72 {item state: reset predefined state} -body {
    .t toggle 8
    .t item state 8
} -result {enabled}

test tree-7.1 {marquee: missing args} -body {
    .t marquee
} -returnCodes error -result {wrong # args: should be ".t marquee command ?arg arg...?"}

test tree-7.2 {marquee: unknown command} -body {
    .t marquee foo
} -returnCodes error -result {bad command "foo": must be anchor, cget, configure, coords, corner, identify, or visible}

test tree-7.3 {marquee anchor: not yet modified} -body {
    .t marquee anchor
} -result {0 0}

test tree-7.4 {marquee anchor: odd arguments} -body {
    .t marquee anchor 1
} -returnCodes error -result {wrong # args: should be ".t marquee anchor ?x y?"}

test tree-7.5 {marquee identify: should be empty} -body {
    .t marquee identify
} -result {}

test tree-7.6 {marquee anchor: set it} -body {
    .t marquee anchor 5 5
} -result {}

test tree-7.7 {marquee coords: retrieve them} -body {
    .t marquee coords
} -result {5 5 0 0}

test tree-7.8 {marquee identify: just the root} -body {
    .t marquee identify
} -result {0}

test tree-7.9 {marquee corner: set it} -body {
    .t marquee corner 600 600
    .t marquee coords
} -result {5 5 600 600}

test tree-7.10 {marquee identify} -body {
    .t marquee identify
} -result {0 {1 0} 2 3 4 5 6 7 {8 {0 eRect eImage}}}

test tree-7.11 {marquee visible} -body {
    list [.t marquee configure -visible] \
	 [.t marquee visible 1] \
	 [.t marquee cget -visible] \
	 [.t marquee visible 0] \
	 [.t marquee cget -visible] \
	 [.t marquee configure -visible 1] \
	 [.t marquee visible]
} -result {{-visible {} {} 0 0} 1 1 0 0 {} 1}

test tree-8.1 {selection: missing args} -body {
    .t selection
} -returnCodes error -result {wrong # args: should be ".t selection command ?arg arg...?"}

test tree-8.2 {selection: unknown command} -body {
    .t selection foo
} -returnCodes error -result {bad command "foo": must be add, anchor, clear, count, get, includes, or modify}

test tree-8.3 {selection count/get: nothing selected yet} -body {
    list [.t selection count] [.t selection get]
} -result {0 {}}

test tree-8.4 {selection anchor: always defined} -body {
    .t selection anchor
} -result {0}

test tree-8.5 {selection anchor: modifies the anchor item} -body {
    .t selection anchor "root lastchild"
    .t index anchor
} -result {8}

test tree-8.6 {selection count/get: still nothing selected} -body {
    list [.t selection count] [.t selection get]
} -result {0 {}}

test tree-8.7 {selection add: all children of an item} -body {
    .t selection add "1 firstchild" "1 lastchild"
    list [.t selection count] [.t selection get]
} -result {2 {2 3}}

test tree-8.8 {selection add: all items and then some} -constraints knownBug -body {
    .t selection add all "1 lastchild"
    list [.t selection count] [.t selection get]
} -result {10 {0 1 2 3 4 5 6 7 8 12}}

test tree-8.9 {selection clear} -body {
    .t selection clear "root firstchild"
    list [.t selection count] [.t selection get]
} -result {9 {0 2 3 4 5 6 7 8 12}}

test tree-8.10 {selection clear: some items and then all} -constraints knownBug -body {
    .t selection clear "root lastchild" all
    list [.t selection count] [.t selection get]
} -result {0 {}}

test tree-8.11 {selection modify: to be or not to be?} -body {
    .t selection modify all all
    list [.t selection count] [.t selection get]
} -result {10 {0 1 2 3 4 5 6 7 8 12}}

test tree-8.12 {selection clear: totally empty} -body {
    .t selection clear
    list [.t selection count] [.t selection get]
} -result {0 {}}

test tree-8.12 {selection modify: to be or not to be?} -body {
    .t selection modify {{root firstchild} {root lastchild}} {{root lastchild}}
    list [.t selection count] [.t selection get]
} -result {2 {1 8}}

test tree-8.13 {selection includes: missing args} -body {
    .t selection includes
} -returnCodes error -result {wrong # args: should be ".t selection includes index"}

test tree-8.14 {selection includes: invalid item} -body {
    .t selection includes {foo bar}
} -returnCodes error -result {bad item description "foo bar"}

test tree-8.15 {selection includes: item is selected} -body {
    .t selection includes {root child 2}
} -result {1}

test tree-8.16 {selection includes: item is not selected} -body {
    .t selection includes {root child 0 firstchild}
} -result {0}

# cleanup
image delete emptyImg
::tcltest::cleanupTests
return
