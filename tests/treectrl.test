# Commands covered:  treectrl
#
# This file contains a collection of tests for the treectrl command of
# the tktreectrl extension.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 2000 by Scriptics Corporation.
# Copyright (c) 2002 by Christian Krone.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: treectrl.test,v 1.11 2002/12/29 08:45:08 krischan Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2
    namespace import ::tcltest::*
}

package require Tk
# This works only, if tktreectrl is already installed:
#   package require treectrl
# And we want to test the currently built version anyway.
# So we better load and source it by hand:
set thisPlatform $tcl_platform(platform)
if {![catch {tk windowingsystem} windowingSystem] \
	&& [string equal aqua $windowingSystem]} {
    set thisPlatform macosx
}
switch -- $thisPlatform {
    macintosh {
	load treectrl.shlb
    }
    macosx {
	load build/treectrl.dylib
    }
    unix {
	load [glob libtreectrl*[info sharedlibextension]]
    }
    default { # Windows
	load Build/treectrl[info sharedlibextension]
    }
}

source [file join library treectrl.tcl]
source [file join library filelist-bindings.tcl]

test tree-1.1 {Usage} -body {
    treectrl
} -returnCodes error -result {wrong # args: should be "treectrl pathName ?options?"}

test tree-1.2 {Unknown option} -body {
    treectrl .t -foo bar
} -returnCodes error -result {unknown option "-foo"}

test tree-1.3 {Create a tree} -body {
    treectrl .t
} -result {.t}

test tree-1.4 {configure: List all options} -body {
    .t configure
} -result {{-background background Background white white} {-backgroundmode backgroundMode BackgroundMode row row} {-bd -borderwidth} {-bg -background} {-borderwidth borderWidth BorderWidth 2 2} {-buttoncolor buttonColor ButtonColor #808080 #808080} {-buttonsize buttonSize ButtonSize 9 9} {-buttonthickness buttonThickness ButtonThickness 1 1} {-closedbuttonbitmap closedButtonBitmap ClosedButtonBitmap {} {}} {-closedbuttonimage closedButtonImage ClosedButtonImage {} {}} {-columnproxy columnProxy ColumnProxy {} {}} {-cursor cursor Cursor {} {}} {-doublebuffer doubleBuffer DoubleBuffer item item} {-fg -foreground} {-font font Font {Helvetica -12 bold} {Helvetica -12 bold}} {-foreground foreground Foreground Black Black} {-height height Height 200 200} {-highlightbackground highlightBackground HighlightBackground #d9d9d9 #d9d9d9} {-highlightcolor highlightColor HighlightColor Black Black} {-highlightthickness highlightThickness HighlightThickness 1 1} {-indent indent Indent 19 19} {-itemheight itemHeight ItemHeight 0 0} {-linecolor lineColor LineColor #808080 #808080} {-linestyle lineStyle LineStyle dot dot} {-linethickness lineThickness LineThickness 1 1} {-openbuttonbitmap openButtonBitmap OpenButtonBitmap {} {}} {-openbuttonimage openButtonImage OpenButtonImage {} {}} {-orient orient Orient vertical vertical} {-relief relief Relief sunken sunken} {-scrollmargin scrollMargin ScrollMargin 0 0} {-selectmode selectMode SelectMode browse browse} {-showbuttons showButtons ShowButtons 1 1} {-showheader showHeader ShowHeader 1 1} {-showlines showLines ShowLines 1 1} {-showroot showRoot ShowRoot 1 1} {-showrootbutton showRootButton ShowRootButton 0 0} {-takefocus takeFocus TakeFocus {} {}} {-treecolumn treeColumn TreeColumn 0 0} {-width width Width 200 200} {-wrap wrap Wrap {} {}} {-xscrollcommand xScrollCommand ScrollCommand {} {}} {-xscrolldelay xScrollDelay ScrollDelay 50 50} {-xscrollincrement xScrollIncrement ScrollIncrement 0 0} {-yscrollcommand yScrollCommand ScrollCommand {} {}} {-yscrolldelay yScrollDelay ScrollDelay 50 50} {-yscrollincrement yScrollIncrement ScrollIncrement 0 0}}

test tree-1.5 {configure -background with totally empty visible tree} -body {
    pack .t
    update idletasks
    .t configure -background white
    update idletasks
} -result {}

test tree-1.6 {configure: -background option} -body {
    .t configure -background yellow
    .t configure -background
} -result {-background background Background white yellow}

test tree-1.7 {configure: invalid -backgroundmode option} -body {
    .t configure -backgroundmode foo
} -returnCodes error -result {bad backgroundmode "foo": must be column, index, row, or visindex}

test tree-1.8 {configure: -backgroundmode option} -body {
    .t configure -backgroundmode column
    .t configure -backgroundmode
} -result {-backgroundmode backgroundMode BackgroundMode row column}

test tree-1.9 {configure: invalid -buttonsize option} -body {
    .t configure -buttonsize foo
} -returnCodes error -result {bad screen distance "foo"}

test tree-1.10 {configure: -buttonsize option} -body {
    .t configure -buttonsize 1c
    .t configure -buttonsize
} -result {-buttonsize buttonSize ButtonSize 9 1c}

test tree-1.11 {configure: invalid -buttoncolor option} -body {
    .t configure -buttoncolor foo
} -returnCodes error -result {unknown color name "foo"}

test tree-1.12 {configure: -buttoncolor option} -body {
    .t configure -buttoncolor red
    .t configure -buttoncolor
} -result {-buttoncolor buttonColor ButtonColor #808080 red}

test tree-1.13 {configure: invalid -openbuttonbitmap option} -body {
    .t configure -openbuttonbitmap foo
} -returnCodes error -result {bitmap "foo" not defined}

test tree-1.14 {configure: -openbuttonbitmap option} -body {
    .t configure -openbuttonbitmap hourglass
    .t configure -openbuttonbitmap
} -result {-openbuttonbitmap openButtonBitmap OpenButtonBitmap {} hourglass}

test tree-1.15 {configure: invalid -closedbuttonbitmap option} -body {
    .t configure -closedbuttonbitmap foo
} -returnCodes error -result {bitmap "foo" not defined}

test tree-1.16 {configure: -closedbuttonbitmap option} -body {
    .t configure -closedbuttonbitmap questhead
    .t configure -closedbuttonbitmap
} -result {-closedbuttonbitmap closedButtonBitmap ClosedButtonBitmap {} questhead}

test tree-1.17 {configure: invalid -openbuttonimage option} -body {
    .t configure -openbuttonimage foo
} -returnCodes error -result {image "foo" doesn't exist}

test tree-1.18 {configure: -openbuttonimage option} -body {
    image create photo emptyImg
    .t configure -openbuttonimage emptyImg
    .t configure -openbuttonimage
} -result {-openbuttonimage openButtonImage OpenButtonImage {} emptyImg}

test tree-1.19 {configure: invalid -closedbuttonimage option} -body {
    .t configure -closedbuttonimage foo
} -returnCodes error -result {image "foo" doesn't exist}

test tree-1.20 {configure: -closedbuttonimage option} -body {
    .t configure -closedbuttonimage emptyImg
    .t configure -closedbuttonimage
} -result {-closedbuttonimage closedButtonImage ClosedButtonImage {} emptyImg}

test tree-1.21 {configure: invalid -doublebuffer option} -body {
    .t configure -doublebuffer foo
} -returnCodes error -result {bad doublebuffer "foo": must be none, item, or window}

test tree-1.22 {configure: -doublebuffer option} -body {
    .t configure -doublebuffer window
    .t configure -doublebuffer
} -result {-doublebuffer doubleBuffer DoubleBuffer item window}

test tree-1.23 {configure: invalid -indent option} -body {
    .t configure -indent foo
} -returnCodes error -result {bad screen distance "foo"}

test tree-1.24 {configure: -indent option} -body {
    .t configure -indent 2c
    .t configure -indent
} -result {-indent indent Indent 19 2c}

test tree-1.25 {configure: invalid -itemheight option} -body {
    .t configure -itemheight foo
} -returnCodes error -result {bad screen distance "foo"}

test tree-1.26 {configure: -itemheight option} -body {
    .t configure -itemheight 18m
    .t configure -itemheight
} -result {-itemheight itemHeight ItemHeight 0 18m}

test tree-1.27 {configure: invalid -linestyle option} -body {
    .t configure -linestyle foo
} -returnCodes error -result {bad linestyle "foo": must be dot or solid}

test tree-1.28 {configure: -linestyle option} -body {
    .t configure -linestyle solid
    .t configure -linestyle
} -result {-linestyle lineStyle LineStyle dot solid}

test tree-1.29 {configure: invalid -linethickness option} -body {
    .t configure -linethickness foo
} -returnCodes error -result {bad screen distance "foo"}

test tree-1.30 {configure: -linethickness option} -body {
    .t configure -linethickness 3m
    .t configure -linethickness
} -result {-linethickness lineThickness LineThickness 1 3m}

test tree-1.31 {configure: invalid -linecolor option} -body {
    .t configure -linecolor #foo
} -returnCodes error -result {invalid color name "#foo"}

test tree-1.32 {configure: -linethickness option} -body {
    .t configure -linecolor gray20
    .t configure -linecolor
} -result {-linecolor lineColor LineColor #808080 gray20}

test tree-1.33 {configure: invalid -orient option} -body {
    .t configure -orient foo
} -returnCodes error -result {bad orient "foo": must be horizontal or vertical}

test tree-1.34 {configure: -orient option} -body {
    .t configure -orient h
    .t configure -orient
} -result {-orient orient Orient vertical horizontal}

test tree-1.35 {configure: invalid -relief option} -body {
    .t configure -relief foo
} -returnCodes error -result {bad relief "foo": must be flat, groove, raised, ridge, solid, or sunken}

test tree-1.36 {configure: -relief option} -body {
    .t configure -relief flat
    .t configure -relief
} -result {-relief relief Relief sunken flat}

test tree-1.37 {configure: invalid -showbuttons option} -body {
    .t configure -showbuttons foo
} -returnCodes error -result {expected boolean value but got "foo"}

test tree-1.38 {configure: -showbuttons option} -body {
    .t configure -showbuttons off
    .t configure -showbuttons
} -result {-showbuttons showButtons ShowButtons 1 0}

test tree-1.39 {configure: invalid -showheader option} -body {
    .t configure -showheader foo
} -returnCodes error -result {expected boolean value but got "foo"}

test tree-1.40 {configure: -showheader option} -body {
    .t configure -showheader off
    .t configure -showheader
} -result {-showheader showHeader ShowHeader 1 0}

test tree-1.41 {configure: invalid -showlines option} -body {
    .t configure -showlines foo
} -returnCodes error -result {expected boolean value but got "foo"}

test tree-1.42 {configure: -showlines option} -body {
    .t configure -showlines false
    .t configure -showlines
} -result {-showlines showLines ShowLines 1 0}

test tree-1.43 {configure: invalid -showroot option} -body {
    .t configure -showroot foo
} -returnCodes error -result {expected boolean value but got "foo"}

test tree-1.44 {configure: -showroot option} -body {
    .t configure -showroot no
    .t configure -showroot
} -result {-showroot showRoot ShowRoot 1 0}

test tree-1.45 {configure: invalid -showrootbutton option} -body {
    .t configure -showrootbutton foo
} -returnCodes error -result {expected boolean value but got "foo"}

test tree-1.46 {configure: -showrootbutton option} -body {
    .t configure -showrootbutton True
    .t configure -showrootbutton
} -result {-showrootbutton showRootButton ShowRootButton 0 1}

test tree-1.47 {configure: invalid -treecolumn option} -body {
    .t configure -treecolumn foo
} -returnCodes error -result {expected integer but got "foo"}

test tree-1.48 {configure: -treecolumn option with unknown column} -body {
    .t configure -treecolumn 1
    .t configure -treecolumn
} -result {-treecolumn treeColumn TreeColumn 0 1}

test tree-1.49 {configure: -treecolumn option with known column} -body {
    .t column configure 0 -tag column0
    .t column configure 1 -tag column1
    .t configure -treecolumn 1
    .t configure -treecolumn
} -result {-treecolumn treeColumn TreeColumn 0 1}

test tree-1.50 {configure: invalid -wrap mode} -body {
    .t configure -wrap foo
} -returnCodes error -result {bad wrap "foo"}

test tree-1.51 {configure: invalid -wrap option: bogus width} -body {
    .t configure -wrap {item bar}
} -returnCodes error -result {bad wrap "item bar"}

test tree-1.52 {configure: invalid -wrap option: superflous width} -body {
    .t configure -wrap {1 window}
} -returnCodes error -result {bad wrap "1 window"}

test tree-1.53 {configure: -wrap option} -body {
    .t configure -wrap {7 items}
    .t configure -wrap
} -result {-wrap wrap Wrap {} {7 items}}

test tree-1.54 {configure: -wrap empty option} -body {
    .t configure -wrap {}
    .t configure -wrap
} -result {-wrap wrap Wrap {} {}}

# For the tests of the item descriptions we use see,
# if we want to generate an error on unknown items.
# For the positive cases we use index since it returns the item number.

test tree-2.1 {bogus itemdesc} -body {
    .t index foo
} -returnCodes error -result {bad item description "foo"}

test tree-2.2 {is all allowed?} -body {
    .t index all
} -returnCodes error -result {can't specify "all" for this command}

test tree-2.3 {itemdesc number unknown} -body {
    .t see 999
} -returnCodes error -result {item "999" doesn't exist}

test tree-2.4 {itemdesc number of root} -body {
    .t index 0
} -result {0}

test tree-2.5 {itemdesc active} -body {
    .t index active
} -result {0}

test tree-2.6 {itemdesc abbreviated anchor} -body {
    .t index an
} -result {0}

test tree-2.7 {itemdesc first} -body {
    .t index first
} -result {0}

test tree-2.8 {itemdesc first visible} -body {
    .t configure -showroot 1
    .t index "first visible"
} -result {0}

test tree-2.9 {itemdesc first visible without any node} -body {
    .t configure -showroot 0
    .t see "first visible"
} -returnCodes error -result {item "first visible" doesn't exist}

test tree-2.10 {itemdesc last} -body {
    .t index last
} -result {0}

test tree-2.11 {itemdesc last visible} -body {
    .t configure -showroot 1
    .t index "last visible"
} -result {0}

test tree-2.12 {itemdesc last visible without any node} -body {
    .t configure -showroot 0
    .t see "last visible"
} -returnCodes error -result {item "last visible" doesn't exist}

test tree-2.13 {itemdesc nearest without x/y} -body {
    .t index nearest
} -returnCodes error -result {bad item description "nearest"}

test tree-2.14 {itemdesc nearest with invalid x/y} -body {
    .t index "nearest foo bar"
} -returnCodes error -result {bad item description "nearest foo bar"}

test tree-2.15 {itemdesc nearest with valid x/y, but no item} -body {
    .t configure -showroot 0
    .t index "nearest 10 10"
} -result {}

# Before continuing to test the item descriptions and their modifiers,
# lets create some items with this hierarchy:
# 0
# + 1
# | + 2
# | + 3
# |   + 4
# + 5
# | + 6
# | + 7
# + 8
test tree-2.16 {create some items} -body {
    set n1 [.t item create]; .t item lastchild 0   $n1
    set n2 [.t item create]; .t item lastchild $n1 $n2
    set n3 [.t item create]; .t item lastchild $n1 $n3
    set n4 [.t item create]; .t item lastchild $n3 $n4
    set n5 [.t item create]; .t item lastchild 0   $n5
    set n6 [.t item create]; .t item lastchild $n5 $n6
    set n7 [.t item create]; .t item lastchild $n5 $n7
    set n8 [.t item create]; .t item lastchild 0   $n8
} -result {8}

test tree-2.17 {itemdesc nearest with valid x/y} -body {
    # I think this should return an item, but it doesn't...
    .t index "nearest 10 10"
} -result {}

test tree-2.18 {itemdesc rnc without r/c} -body {
    .t index rnc
} -returnCodes error -result {bad item description "rnc"}

test tree-2.19 {itemdesc rnc with invalid r/c} -body {
    .t index "rnc foo bar"
} -returnCodes error -result {bad item description "rnc foo bar"}

test tree-2.20 {itemdesc rnc with valid r/c} -body {
    .t index "rnc 0 0"
} -result {1}

test tree-2.21 {itemdesc root} -body {
    .t configure -showroot 1 -orient vertical
    .t index root
} -result {0}

test tree-2.22 {bogus modifier} -body {
    .t index "0 foo"
} -returnCodes error -result {bad modifier "foo": must be above, below, bottom, child, firstchild, lastchild, left, leftmost, next, nextsibling, parent, prev, prevsibling, right, rightmost, sibling, top, or visible}

test tree-2.23 {valid modifier with too less arguments} -body {
    .t index "0 child"
} -returnCodes error -result {bad item description "0 child"}

test tree-2.24 {modifier visible alone generates an error} -body {
    .t index "0 visible"
} -returnCodes error -result {bad item description "0 visible"}

test tree-2.25 {modifier above} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n above"]
    }
    set res
} -result {{} 0 1 2 3 4 5 6 7}

test tree-2.26 {modifier below} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n below"]
    }
    set res
} -result {1 2 3 4 5 6 7 8 {}}

test tree-2.27 {modifier bottom} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n bottom"]
    }
    set res
} -result {8 8 8 8 8 8 8 8 8}

test tree-2.28 {modifier child} -body {
    set res {}
    for {set n 0} {$n < 6} {incr n} {
	for {set c 0} {$c < 3} {incr c} {
	    lappend res [.t index "$n child $c"]
	}
    }
    set res
} -result {1 5 8 2 3 {} {} {} {} 4 {} {} {} {} {} 6 7 {}}

test tree-2.29 {modifier firstchild} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n firstchild"]
    }
    set res
} -result {1 2 {} 4 {} 6 {} {} {}}

test tree-2.30 {modifier lastchild} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n lastchild"]
    }
    set res
} -result {8 3 {} 4 {} 7 {} {} {}}

test tree-2.30 {modifier left, leftmost, right, and rightmost} -body {
    list [.t index "1 left"] [.t index "1 right"] \
	 [.t index "2 leftmost"] [.t index "3 rightmost"]
} -result {{} {} 2 3}

test tree-2.31 {modifier next} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n next"]
    }
    set res
} -result {1 2 3 4 5 6 7 8 {}}

test tree-2.32 {modifier nextsibling} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n nextsibling"]
    }
    set res
} -result {{} 5 3 {} {} 8 7 {} {}}

test tree-2.33 {modifier parent} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n parent"]
    }
    set res
} -result {{} 0 1 1 3 0 5 5 0}

test tree-2.34 {modifier prev} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n prev"]
    }
    set res
} -result {{} 0 1 2 3 4 5 6 7}

test tree-2.34 {modifier prevsibling} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n prevsibling"]
    }
    set res
} -result {{} {} {} 2 {} 1 {} 6 5}

test tree-2.35 {modifier sibling} -body {
    set res {}
    for {set n 0} {$n < 7} {incr n} {
	for {set c 0} {$c < 3} {incr c} {
	    lappend res [.t index "$n sibling $c"]
	}
    }
    set res
} -result {{} {} {} 1 5 8 2 3 {} 2 3 {} 4 {} {} 1 5 8 6 7 {}}

test tree-2.36 {modifier top} -body {
    set res {}
    for {set n 0} {$n < 9} {incr n} {
	lappend res [.t index "$n top"]
    }
    set res
} -result {0 0 0 0 0 0 0 0 0}

test tree-2.37 {modifier cocktail} -body {
    set res {}
    set itemDesc 7
    foreach mod {
	bottom rightmost sibling 0 nextsibling prev parent
	prevsibling prev nextsibling lastchild next
    } {
	lappend itemDesc $mod
	catch {lappend res [.t index $itemDesc]}
    }
    set res
} -result {8 8 1 5 4 3 2 1 5 7 8}

test tree-3.1 {element: missing op} -body {
    .t element
} -returnCodes error -result {wrong # args: should be ".t element command ?arg arg...?"}

test tree-3.2 {element create: missing argument} -body {
    .t element create
} -returnCodes error -result {wrong # args: should be ".t element create name type ?option value...?"}

test tree-3.3 {element create: unknown type} -body {
    .t element create foo bar
} -returnCodes error -result {unknown element type "bar"}

test tree-3.4 {element create: a bitmap} -body {
    .t element create eBitmap bitmap
} -result {eBitmap}

test tree-3.5 {element configure: for a bitmap} -body {
    .t element configure eBitmap
} -result {{-background {} {} {} {}} {-bitmap {} {} {} {}} {-foreground {} {} {} {}}}

test tree-3.6 {element configure: bitmap invalid -background} -body {
    .t element configure eBitmap -background blur
} -returnCodes error -result {unknown color name "blur"}

test tree-3.7 {element configure/cget: bitmap -background} -body {
    .t element configure eBitmap -background blue
    .t element cget eBitmap -background
} -result {blue}

test tree-3.8 {element configure: bitmap invalid psd -background} -body {
    .t element configure eBitmap -background {blue !selected blur {}}
} -returnCodes error -result {unknown color name "blur"}

test tree-3.9 {element configure/cget: bitmap psd -background} -body {
    .t element configure eBitmap -background {blue open magenta {}}
    .t element cget eBitmap -background
} -result {blue open magenta {}}

test tree-3.10 {element configure/cget: bitmap invalid -bitmap} -body {
    .t element configure eBitmap -bitmap notExists
} -returnCodes error -result {bitmap "notExists" not defined}

test tree-3.11 {element configure/cget: bitmap -bitmap} -body {
    .t element configure eBitmap -bitmap questhead
    .t element cget eBitmap -bitmap
} -result {questhead}

test tree-3.12 {element configure: bitmap invalid psd -bitmap} -body {
    .t element configure eBitmap -bitmap {questhead selected yep {}}
} -returnCodes error -result {bitmap "yep" not defined}

test tree-3.13 {element configure/cget: bitmap psd -background} -body {
    .t element configure eBitmap -bitmap {questhead !open error {}}
    .t element cget eBitmap -bitmap
} -result {questhead !open error {}}

test tree-3.14 {element configure: bitmap invalid -foreground} -body {
    .t element configure eBitmap -foreground foobar
} -returnCodes error -result {unknown color name "foobar"}

test tree-3.15 {element configure/cget: bitmap -foreground} -body {
    .t element configure eBitmap -foreground yellow
    .t element cget eBitmap -foreground
} -result {yellow}

test tree-3.16 {element configure: bitmap invalid psd -foreground} -body {
    .t element configure eBitmap -foreground {blue ! red {}}
} -returnCodes error -result {unknown state ""}

test tree-3.17 {element configure/cget: bitmap psd -foreground} -body {
    .t element configure eBitmap -foreground {blue open red !selected}
    .t element cget eBitmap -foreground
} -result {blue open red !selected}

test tree-3.18 {element create: a border} -body {
    .t element create eBorder border
} -result {eBorder}

test tree-3.19 {element configure: for a border} -body {
    .t element configure eBorder
} -result {{-background {} {} {} {}} {-filled {} {} {} {}} {-height {} {} {} {}} {-relief {} {} {} {}} {-thickness {} {} {} {}} {-width {} {} {} {}}}

test tree-3.20 {element configure: border invalid -background} -body {
    .t element configure eBorder -background #
} -returnCodes error -result {invalid color name "#"}

test tree-3.21 {element configure/cget: border -background} -body {
    .t element configure eBorder -background #010101
    .t element cget eBorder -background
} -result {#010101}

test tree-3.22 {element configure: border invalid psd -background} -body {
    .t element configure eBorder -background {blue active red !}
} -returnCodes error -result {unknown state ""}

test tree-3.23 {element configure/cget: border psd -background} -body {
    .t element configure eBorder -background {blue !open red selected}
    .t element cget eBorder -background
} -result {blue !open red selected}

test tree-3.24 {element configure: border invalid -filled} -body {
    .t element configure eBorder -filled foo
} -returnCodes error -result {expected boolean value but got "foo"}

test tree-3.25 {element configure/cget: border -filled} -body {
    .t element configure eBorder -filled 1
    .t element cget eBorder -filled
} -result {1}

test tree-3.26 {element configure: border invalid -height} -body {
    .t element configure eBorder -height {200 300}
} -returnCodes error -result {bad screen distance "200 300"}

test tree-3.27 {element configure/cget: border -height} -body {
    .t element configure eBorder -height 200
    .t element cget eBorder -height
} -result {200}

test tree-3.28 {element configure: border invalid -relief} -body {
    .t element configure eBorder -relief groovy
} -returnCodes error -result {bad relief "groovy": must be flat, groove, raised, ridge, solid, or sunken}

test tree-3.29 {element configure/cget: border -relief} -body {
    .t element configure eBorder -relief ridge
    .t element cget eBorder -relief
} -result {ridge}

test tree-3.30 {element configure: border invalid psd -relief} -body {
    .t element configure eBorder -relief {groove open ridge}
} -returnCodes error -result {list must have even number of elements}

test tree-3.31 {element configure/cget: border psd -relief} -body {
    .t element configure eBorder -relief {groove !open ridge {}}
    .t element cget eBorder -relief
} -result {groove !open ridge {}}

test tree-3.32 {element configure: border invalid -thickness} -body {
    .t element configure eBorder -thickness jup
} -returnCodes error -result {bad screen distance "jup"}

test tree-3.33 {element configure/cget: border -thickness} -body {
    .t element configure eBorder -thickness 8
    .t element cget eBorder -thickness
} -result {8}

test tree-3.34 {element configure: border invalid -width} -body {
    .t element configure eBorder -width {300 200}
} -returnCodes error -result {bad screen distance "300 200"}

test tree-3.35 {element configure/cget: border -width} -body {
    .t element configure eBorder -width 300
    .t element cget eBorder -width
} -result {300}

test tree-3.36 {element create: an image} -body {
    .t element create eImage image
} -result {eImage}

test tree-3.37 {element configure: for an image} -body {
    .t element configure eImage
} -result {{-height {} {} {} {}} {-image {} {} {} {}} {-width {} {} {} {}}}

test tree-3.38 {element configure: image invalid -height} -body {
    .t element configure eImage -height {101 open 200 {}}
} -returnCodes error -result {bad screen distance "101 open 200 {}"}

test tree-3.39 {element configure/cget: image -height} -body {
    .t element configure eImage -height 101
    .t element cget eImage -height
} -result {101}

test tree-3.40 {element configure: image unknown -image} -body {
    .t element configure eImage -image foo
} -returnCodes error -result {image "foo" doesn't exist}

test tree-3.41 {element configure/cget: image -image} -body {
    .t element configure eImage -image emptyImg
    .t element cget eImage -image
} -result {emptyImg}

test tree-3.42 {element configure: image invalid psd -image} -body {
    .t element configure eImage -image {emptyImg open dirImg}
} -returnCodes error -result {list must have even number of elements}

test tree-3.43 {element configure/cget: image psd -image} -body {
    .t element configure eImage -image {emptyImg {}}
    .t element cget eImage -image
} -result {emptyImg {}}

test tree-3.44 {element configure: image invalid -width} -body {
    .t element configure eImage -width {202 boo}
} -returnCodes error -result {bad screen distance "202 boo"}

test tree-3.45 {element configure/cget: image -width} -body {
    .t element configure eImage -width 202
    .t element cget eImage -width
} -result {202}

test tree-3.46 {element create: a rectangle} -body {
    .t element create eRect rect
} -result {eRect}

test tree-3.47 {element configure: for a rectangle} -body {
    .t element configure eRect
} -result {{-fill {} {} {} {}} {-height {} {} {} {}} {-open {} {} {} {}} {-outline {} {} {} {}} {-outlinewidth {} {} {} {}} {-showfocus {} {} {} {}} {-width {} {} {} {}}}

test tree-3.48 {element configure: rectangle invalid -fill} -body {
    .t element configure eRect -fill baz
} -returnCodes error -result {unknown color name "baz"}

test tree-3.49 {element configure/cget: rectangle -fill} -body {
    .t element configure eRect -fill blue
    .t element cget eRect -fill
} -result {blue}

test tree-3.50 {element configure: rectangle invalid psd -fill} -body {
    .t element configure eRect -fill {red blue yellow green}
} -returnCodes error -result {unknown state "blue"}

test tree-3.51 {element configure/cget: rectangle psd -fill} -body {
    .t element configure eRect -fill {red open blue {}}
    .t element cget eRect -fill
} -result {red open blue {}}

test tree-3.52 {element configure: rectangle invalid -height} -body {
    .t element configure eRect -height 100b
} -returnCodes error -result {bad screen distance "100b"}

test tree-3.53 {element configure/cget: rectangle -height} -body {
    .t element configure eRect -height 200
    .t element cget eRect -height
} -result {200}

test tree-3.54 {element configure: rectangle invalid -open} -body {
    .t element configure eRect -open now
} -returnCodes error -result {bad open value "now": must be a string containing zero or more of n, e, s, and w}

test tree-3.55 {element configure/cget: rectangle -open} -body {
    .t element configure eRect -open n
    .t element cget eRect -open
} -result {n}

test tree-3.56 {element configure: rectangle invalid -outline} -body {
    .t element configure eRect -outline baz
} -returnCodes error -result {unknown color name "baz"}

test tree-3.57 {element configure/cget: rectangle -outline} -body {
    .t element configure eRect -outline blue
    .t element cget eRect -outline
} -result {blue}

test tree-3.58 {element configure: rectangle invalid psd -outline} -body {
    .t element configure eRect -outline {red blue yellow green}
} -returnCodes error -result {unknown state "blue"}

test tree-3.59 {element configure/cget: rectangle psd -outline} -body {
    .t element configure eRect -outline {red {} blue open}
    .t element cget eRect -outline
} -result {red {} blue open}

test tree-3.60 {element configure: rectangle invalid -outlinewidth} -body {
    .t element configure eRect -outlinewidth baz
} -returnCodes error -result {bad screen distance "baz"}

test tree-3.61 {element configure/cget: rectangle -outlinewidth} -body {
    .t element configure eRect -outlinewidth 1c
    .t element cget eRect -outlinewidth
} -result {1c}

test tree-3.62 {element configure: rectangle invalid -showfocus} -body {
    .t element configure eRect -showfocus baz
} -returnCodes error -result {expected boolean value but got "baz"}

test tree-3.63 {element configure/cget: rectangle -showfocus} -body {
    .t element configure eRect -showfocus 1
    .t element cget eRect -showfocus
} -result {1}

test tree-3.64 {element configure: rectangle invalid -width} -body {
    .t element configure eRect -width baz
} -returnCodes error -result {bad screen distance "baz"}

test tree-3.65 {element configure/cget: rectangle -width} -body {
    .t element configure eRect -width 10c
    .t element cget eRect -width
} -result {10c}

test tree-3.66 {element create: a text} -body {
    .t element create eText text
} -result {eText}

test tree-3.67 {element configure: for a text} -body {
    .t element configure eText
} -result {{-data {} {} {} {}} {-datatype {} {} {} {}} {-format {} {} {} {}} {-fill {} {} {} {}} {-font {} {} {} {}} {-justify {} {} {} {}} {-lines {} {} {} {}} {-text {} {} {} {}} {-width {} {} {} {}} {-wrap {} {} {} {}}}

test tree-3.68 {element configure/cget: text -data} -body {
    .t element configure eText -data "1.23456789"
    .t element cget eText -data
} -result {1.23456789}

test tree-3.69 {element configure: text invalid -datatype} -body {
    .t element configure eText -datatype float
} -returnCodes error -result {bad datatype "float": must be double, integer, long, string, or time}

test tree-3.70 {element configure/cget: text -datatype} -body {
    .t element configure eText -datatype double
    .t element cget eText -datatype
} -result {double}

test tree-3.71 {element configure: text invalid -fill} -body {
    .t element configure eText -fill baz
} -returnCodes error -result {unknown color name "baz"}

test tree-3.72 {element configure/cget: text -fill} -body {
    .t element configure eText -fill blue
    .t element cget eText -fill
} -result {blue}

test tree-3.73 {element configure: text invalid psd -fill} -body {
    .t element configure eText -fill {red blue yellow green}
} -returnCodes error -result {unknown state "blue"}

test tree-3.74 {element configure/cget: text psd -fill} -body {
    .t element configure eText -fill {red open blue {}}
    .t element cget eText -fill
} -result {red open blue {}}

test tree-3.75 {element configure/cget: text -format} -body {
    .t element configure eText -format "The value of the double is a secret"
    .t element cget eText -format
} -result {The value of the double is a secret}

test tree-3.76 {element configure: text invalid -font} -body {
    # Invalid font doesn't generate an error...
    .t element configure eText -font {"Australia 12"}
   .t element cget eText -font
} -result {"Australia 12"}

test tree-3.77 {element configure/cget: text -font} -body {
    .t element configure eText -font {"Helvetica 12"}
    .t element cget eText -font
} -result {"Helvetica 12"}

test tree-3.78 {element configure: text invalid psd -font} -body {
    .t element configure eText -font {"Australia 12" opened}
} -returnCodes error -result {unknown state "opened"}

test tree-3.79 {element configure/cget: text -font} -body {
    .t element configure eText -font {"Helvetica 12" open "Times 18" {}}
    .t element cget eText -font
} -result {"Helvetica 12" open "Times 18" {}}

test tree-3.80 {element configure: text invalid -justify} -body {
    .t element configure eText -justify north
} -returnCodes error -result {bad justification "north": must be left, right, or center}

test tree-3.81 {element configure/cget: text -justify} -body {
    .t element configure eText -justify center
    .t element cget eText -justify
} -result {center}

test tree-3.82 {element configure: text invalid -lines} -body {
    .t element configure eText -lines asap
} -returnCodes error -result {expected integer but got "asap"}

test tree-3.83 {element configure/cget: text -lines} -body {
    .t element configure eText -lines 5
    .t element cget eText -lines
} -result {5}

test tree-3.84 {element configure/cget: text -text} -body {
    .t element configure eText -text "Hallo Welt"
    .t element cget eText -text
} -result {Hallo Welt}

test tree-3.85 {element configure: text invalid -wrap} -body {
    .t element configure eText -wrap none
} -returnCodes error -result {bad wrap "none": must be char or word}

test tree-3.86 {element configure/cget: text -wrap} -body {
    .t element configure eText -wrap char
    .t element cget eText -wrap
} -result {char}

test tree-3.87 {element types} -body {
    set res {}
    foreach e {eBitmap eBorder eImage eRect eText} {
	lappend res [.t element type $e]
    }
    set res
} -result {bitmap border image rect text}

test tree-3.88 {element names} -body {
    lsort [.t element names]
} -result {eBitmap eBorder eImage eRect eText}

test tree-3.89 {element delete with something unknown in middle} -body {
    .t element delete eBitmap eNotExist eBorder
} -returnCodes error -result {element "eNotExist" doesn't exist}

test tree-3.90 {element names} -body {
    lsort [.t element names]
} -result {eBorder eImage eRect eText}

test tree-4.1 {style: missing args} -body {
    .t style
} -returnCodes error -result {wrong # args: should be ".t style command ?arg arg...?"}

test tree-4.2 {style: invalid command} -body {
    .t style foo
} -returnCodes error -result {bad command "foo": must be cget, configure, create, delete, elements, layout, or names}

test tree-4.3 {style names: no style exists yet} -body {
    .t style names
} -result {}

test tree-4.4 {style create: missing args} -body {
    .t style create
} -returnCodes error -result {wrong # args: should be ".t style create name ?option value...?"}

test tree-4.5 {style create: invalid option} -body {
    .t style create testStyle -foo bar
} -returnCodes error -result {unknown option "-foo"}

test tree-4.6 {style create} -body {
    .t style create testStyle
} -result {testStyle}

test tree-4.7 {style create: already existing style} -body {
    .t style create testStyle
} -returnCodes error -result {style "testStyle" already exists}

test tree-4.8 {style configure: invalid option} -body {
    .t style configure testStyle -foo bar
} -returnCodes error -result {unknown option "-foo"}

test tree-4.9 {style configure: all options} -body {
    .t style configure testStyle
} -result {{-orient {} {} horizontal horizontal}}

test tree-4.10 {style configure: the only option} -body {
    .t style configure testStyle -orient
} -result {-orient {} {} horizontal horizontal}

test tree-4.11 {style configure: invalid option -orient} -body {
    .t style configure testStyle -orient diagonal
} -returnCodes error -result {bad orient "diagonal": must be horizontal or vertical}

test tree-4.12 {style configure/cget: option -orient} -body {
    .t style configure testStyle -orient vertical
    .t style cget testStyle -orient
} -result {vertical}

test tree-4.13 {style delete: unknown style} -body {
    .t style delete testStyle2
} -returnCodes error -result {style "testStyle2" doesn't exist}

test tree-4.14 {style delete: unknown style} -body {
    .t style names
} -result {testStyle}

test tree-4.15 {style delete} -body {
    .t style delete testStyle
} -result {}

test tree-4.16 {style names: no style defined} -body {
    .t style names
} -result {}

test tree-4.17 {style elements: missing args} -body {
    .t style elements
} -returnCodes error -result {wrong # args: should be ".t style elements name ?element element...?"}

test tree-4.18 {style elements: unknown style} -body {
    .t style elements testStyle
} -returnCodes error -result {style "testStyle" doesn't exist}

test tree-4.19 {style elements: no element yet} -body {
    .t style create testStyle
    .t style elements testStyle
} -result {}

test tree-4.20 {style elements: empty element list} -body {
    .t style elements testStyle {}
} -result {}

test tree-4.21 {style elements: add some elements} -body {
    .t style elements testStyle {eBorder eImage eText}
    .t style elements testStyle
} -result {eBorder eImage eText}

test tree-4.22 {style layout: missing args} -body {
    .t style layout
} -returnCodes error -result {wrong # args: should be ".t style layout name element ?option? ?value? ?option value ...?"}

test tree-4.23 {style layout: no options specified} -body {
    .t style layout testStyle eText
} -result {-padw 0 -padn 0 -pade 0 -pads 0 -ipadw 0 -ipadn 0 -ipade 0 -ipads 0 -expand {} -iexpand {} -detach no -squeeze {} -union {}}

test tree-4.24 {style layout: option -pads} -body {
    .t style layout testStyle eText -pads 3
    .t style layout testStyle eText -pads
} -result {3}

test tree-4.25 {style layout: option -expand} -body {
    .t style layout testStyle eText -expand "hello world"
} -returnCodes error -result {bad expand value "hello world": must be a string containing zero or more of n, e, s, and w}

test tree-4.25a {style layout: option -expand} -body {
    .t style layout testStyle eText -expand ew
    .t style layout testStyle eText -expand
} -result {we}

test tree-4.26 {style layout: option -squeeze} -body {
    .t style layout testStyle eText -squeeze xyzzy
} -returnCodes error -result {bad squeeze value "xyzzy": must be a string containing zero or more of x and y}

test tree-4.26a {style layout: option -squeeze} -body {
    .t style layout testStyle eText -squeeze xy
    .t style layout testStyle eText -squeeze
} -result {xy}

test tree-4.27 {style layout: option -union invalid list} -body {
    .t style layout testStyle eText -union "\{"
} -returnCodes error -result {unmatched open brace in list}

test tree-4.28 {style layout: option -union unknown elements} -body {
    .t style layout testStyle eText -union {foo bar}
} -returnCodes error -result {element "foo" doesn't exist}

test tree-4.29 {style layout: option -union element not in style} -body {
    .t style layout testStyle eText -union {eBorder eRect}
} -returnCodes error -result {style testStyle does not use element eRect}

test tree-4.30 {style layout: option -union with itself} -body {
    .t style layout testStyle eText -union {eBorder eText}
} -returnCodes error -result {element eText can't form union with itself}

test tree-4.31 {style layout: option -union} -body {
    .t style layout testStyle eText -union {eBorder eImage}
    .t style layout testStyle eText -union
} -result {eBorder eImage}

test tree-4.32 {style layout: option invalid -detach} -body {
    .t style layout testStyle eText -detach {x y}
} -returnCodes error -result {expected boolean value but got "x y"}

test tree-4.33 {style layout: option -detach} -body {
    .t style layout testStyle eText -detach true
    .t style layout testStyle eText -detach
} -result {1}

test tree-5.1 {state: missing args} -body {
    .t state
} -returnCodes error -result {wrong # args: should be ".t state command ?arg arg...?"}

test tree-5.2 {state: invalid command} -body {
    .t state foo
} -returnCodes error -result {bad command "foo": must be define, undefine, or names}

test tree-5.3 {state names: too many args} -body {
    .t state names foo bar
} -returnCodes error -result {wrong # args: should be ".t state names"}

test tree-5.4 {state names: no states defined yet} -body {
    .t state names
} -result {}

test tree-5.5 {state define: missing args} -body {
    .t state define
} -returnCodes error -result {wrong # args: should be ".t state define stateName"}

test tree-5.6 {state define: overflow check} -body {
    set msg ""
    set ret 0
    for {set ix 0} {$ix < 1000} {incr ix} {
	set ret [catch {.t state define state$ix} msg]
	if {$ret} {break}
    }
    list $ret $ix $msg
} -result {1 27 {cannot define any more states}}

test tree-5.7 {state names} -body {
    .t state names
} -result {state0 state1 state2 state3 state4 state5 state6 state7 state8 state9 state10 state11 state12 state13 state14 state15 state16 state17 state18 state19 state20 state21 state22 state23 state24 state25 state26}

test tree-5.8 {state undefine: missing args is ok} -body {
    .t state undefine
} -result {}

test tree-5.9 {state undefine: too many args} -body {
    eval {.t state undefine} [lrange [.t state names] 3 end]
    .t state names
} -result {state0 state1 state2}

test tree-5.10 {state undefine} -body {
    foreach state [lrange [.t state names] 1 end] {
	.t state undefine $state
    }
    .t state names
} -result {state0}

test tree-6.1 {item: missing command} -body {
    .t item
} -returnCodes error -result {wrong # args: should be ".t item command ?arg arg...?"}

test tree-6.2 {item: invalid command} -body {
    .t item foo
} -returnCodes error -result {bad command "foo": must be ancestors, children, create, delete, firstchild, lastchild, nextsibling, numchildren, parent, prevsibling, remove, bbox, complex, dump, element, hasbutton, index, isancestor, isopen, rnc, sort, state, style, text, or visible}

test tree-6.3 {item create: too many args} -body {
    .t item create foo
} -returnCodes error -result {wrong # args: should be ".t item create"}

test tree-6.4 {item create} -body {
    list [.t item create] [.t item create] [.t item create]
} -result {9 10 11}

test tree-6.5 {item delete: missing itemDesc} -body {
    .t item delete
} -returnCodes error -result {wrong # args: should be ".t item delete first ?last?"}

test tree-6.6 {item delete: unknown item} -body {
    .t item delete 999
} -returnCodes error -result {item "999" doesn't exist}

test tree-6.7 {item delete: one item} -body {
    .t item delete 9
} -result {}

test tree-6.8 {item delete: item range without common ancestor} -body {
    .t item delete 10 11
} -returnCodes error -result {item 10 and item 11 don't share a common ancestor}

test tree-6.9 {item delete: item range without common ancestor} -body {
    .t item lastchild 8 10
    .t item lastchild 8 11
    .t item delete 10 11
} -result {}

test tree-6.9a {item delete: don't delete "root" itemDesc} -body {
    .t item delete root
    .t index root
} -result {0}

test tree-6.9b {item delete: deleting root should be ignored} -body {
    .t item delete [.t index root]
    update idletasks
} -result {}

test tree-6.10 {item ancestors: no ancestor yet} -body {
    .t item create
    .t item ancestors 12
} -result {}

test tree-6.11 {item ancestors} -body {
    .t item lastchild 7 12
    .t item ancestors 12
} -result {7 5 0}

test tree-6.12 {item children: no children} -body {
    .t item children 12
} -result {}

test tree-6.13 {item children} -body {
    .t item children 0
} -result {1 5 8}

test tree-6.14 {item firstchild: missing itemDesc} -body {
    .t item firstchild
} -returnCodes error -result {wrong # args: should be ".t item firstchild item ?newFirstChild?"}

test tree-6.15 {item firstchild: no children} -body {
    .t item firstchild 12
} -result {}

test tree-6.16 {item firstchild} -body {
    .t item firstchild 1
} -result {2}

test tree-6.17 {item lastchild: no children} -body {
    .t item lastchild 1
} -result {3}

test tree-6.18 {item nextsibling: no sibling} -body {
    .t item nextsibling 12
} -result {}

test tree-6.19 {item nextsibling: no sibling} -body {
    .t item nextsibling 2
} -result {3}

test tree-6.20 {item numchildren: no children} -body {
    .t item numchildren 12
} -result {0}

test tree-6.21 {item numchildren} -body {
    .t item numchildren 1
} -result {2}

test tree-6.22 {item parent: no parent} -body {
    .t item parent root
} -result {}

test tree-6.23 {item parent} -body {
    .t item parent "root firstchild"
} -result {0}

test tree-6.24 {item prevsibling: missing arg} -body {
    .t item prevsibling
} -returnCodes error -result {wrong # args: should be ".t item prevsibling item ?newPrevSibling?"}

test tree-6.25 {item prevsibling: no prevsibling} -body {
    .t item prevsibling 1
} -result {}

test tree-6.26 {item prevsibling} -body {
    .t item prevsibling 3
} -result {2}

test tree-6.27 {item remove: invalid item} -body {
    .t item remove 999
} -returnCodes error -result {item "999" doesn't exist}

test tree-6.28 {item remove} -body {
    .t item remove 12
} -result {}

test tree-6.29 {item complex: missing args} -body {
    .t item complex 8
} -returnCodes error -result {wrong # args: should be ".t item complex item list..."}

test tree-6.30 {item complex: only allowed if column style is defined} -body {
    .t item complex 8 {{e1 -text Hallo}}
} -returnCodes error -result {item 8 doesn't have column 0}

test tree-6.31 {item complex: invalid list} -body {
    .t item style set 8 0 testStyle
    .t item complex 8 {{e1 -text}}
} -returnCodes error -result {wrong # args: should be "element option value..."}

test tree-6.32 {item complex: element name not defined in style} -body {
    .t item complex 8 {{e1 -text Hallo}}
} -returnCodes error -result {element "e1" doesn't exist}

test tree-6.33 {item complex: option not known in element} -body {
    .t item complex 8 {{eText -bitmap questhead}}
} -returnCodes error -result {unknown option "-bitmap"}

test tree-6.34 {item complex: invalid option value in element} -body {
    .t item complex 8 {{eText -fill foo}}
} -returnCodes error -result {unknown color name "foo"}

test tree-6.35 {item element: missing command} -body {
    .t item element
} -returnCodes error -result {wrong # args: should be ".t item element command item column element ?arg ...?"}

test tree-6.36 {item element: invalid command} -body {
    .t item element foo 8 0 eText
} -returnCodes error -result {bad command "foo": must be actual, cget, or configure}

test tree-6.37 {item element actual: missing arg} -body {
    .t item element actual 8 0 eText
} -returnCodes error -result {wrong # args: should be ".t item element actual item column element option"}

test tree-6.38 {item element actual} -body {
    .t item element actual 8 0 eText -fill
} -result {red}

test tree-6.39 {item element cget: missing arg} -body {
    .t item element cget 8 0 eText
} -returnCodes error -result {wrong # args: should be ".t item element cget item column element option"}

test tree-6.40 {item element cget} -body {
    .t item element cget 8 0 eText -fill
} -result {}

test tree-6.41 {item element configure} -body {
    .t item element configure 8 0 eText
} -result {{-data {} {} {} {}} {-datatype {} {} {} {}} {-format {} {} {} {}} {-fill {} {} {} {}} {-font {} {} {} {}} {-justify {} {} {} {}} {-lines {} {} {} {}} {-text {} {} {} {}} {-width {} {} {} {}} {-wrap {} {} {} {}}}

test tree-6.42 {item element configure/cget} -body {
    .t item element configure 8 0 eText -fill yellow
    .t item element cget 8 0 eText -fill
} -result {yellow}

test tree-6.43 {item element configure} -body {
    .t item element configure 8 0 eText -fill
} -result {-fill {} {} {} yellow}

test tree-6.44 {item style: missing args} -body {
    .t item style
} -returnCodes error -result {wrong # args: should be ".t item style command item ?arg ...?"}

test tree-6.45 {item style: invalid command} -body {
    .t item style foo bar
} -returnCodes error -result {bad command "foo": must be elements, map, or set}

test tree-6.45 {item style: invalid command} -body {
    .t item style foo bar
} -returnCodes error -result {bad command "foo": must be elements, map, or set}

test tree-6.46 {item style elements: missing args} -body {
    .t item style elements 8
} -returnCodes error -result {wrong # args: should be ".t item style elements item column"}

test tree-6.47 {item style elements: invalid item} -body {
    .t item style elements 999
} -returnCodes error -result {item "999" doesn't exist}

test tree-6.48 {item style elements: item without style} -body {
    .t item style elements 1 0
} -returnCodes error -result {item 1 doesn't have column 0}

test tree-6.49 {item style elements} -body {
    .t item style elements 8 0
} -result {eText}

test tree-6.50 {item style map: missing args} -body {
    .t item style map 8
} -returnCodes error -result {wrong # args: should be ".t item style map item column style map"}

test tree-6.51 {item style map: invalid item} -body {
    .t item style map 999
} -returnCodes error -result {item "999" doesn't exist}

test tree-6.52 {item style map: item with unknown style} -body {
    .t item style map 1 0 noStyle {foo bar}
} -returnCodes error -result {style "noStyle" doesn't exist}

test tree-6.53 {item style map: odd elemented list} -body {
    .t item style map 8 0 testStyle foo
    .t item style elements 8 0
} -returnCodes error -result {list must contain even number of elements}

test tree-6.54 {item style map: unknown element} -body {
    .t style create testStyle2
    .t item style map 8 0 testStyle2 {eText foo}
    .t item style elements 8 0
} -returnCodes error -result {element "foo" doesn't exist}

test tree-6.55 {item style map: element not in to-style} -body {
    .t item style map 8 0 testStyle2 {eText eRect}
} -returnCodes error -result {style testStyle2 does not use element eRect}

test tree-6.56 {item style map: element not in from-style} -body {
    # .t style elements testStyle2 {eImage eRect}
    .t item style map 8 0 testStyle2 {eRect eBorder}
} -returnCodes error -result {style testStyle does not use element eRect}

test tree-6.57 {item style map: different element types} -body {
    .t style elements testStyle2 {eImage eRect}
    .t item style map 8 0 testStyle2 {eBorder eRect}
} -returnCodes error -result {can't map element type border to rect}

test tree-6.58 {item style set: invalid item} -body {
    .t item style set foo bar
} -returnCodes error -result {bad item description "foo"}

test tree-6.59 {item style set: without args returns all styles} -body {
    .t item style set 2
} -result {}

test tree-6.60 {item style set: without args returns style} -body {
    .t item style set 2 0
} -returnCodes error -result {item 2 doesn't have column 0}

test tree-6.61 {item style set: without args returns style} -body {
    .t item style set 8 0
} -result {testStyle}

test tree-6.62 {item style set} -body {
    .t item style set 8 0 testStyle2
    .t item style set 8
} -result {testStyle2}

test tree-6.63 {item state: missing args} -body {
    .t item state
} -returnCodes error -result {wrong # args: should be ".t item state item ?state ...?"}

test tree-6.64 {item state: unknown item} -body {
    .t item state 999
} -returnCodes error -result {item "999" doesn't exist}

test tree-6.65 {item state: list all set states} -body {
    .t item state 8
} -result {open enabled}

test tree-6.66 {item state: try to reset predefined state} -body {
    .t item state 8 !open
} -returnCodes error -result {cannot change state "!open"}

test tree-6.67 {item state: unknown states} -body {
    .t item state 8 foo bar
} -returnCodes error -result {cannot change state "foo"}

test tree-6.68 {item state: switch on states} -body {
    .t item state 8 state0
    .t item state 8
} -result {open enabled state0}

test tree-6.69 {item state: switch off states} -body {
    .t item state 8 !state0
    .t item state 8
} -result {open enabled}

test tree-6.70 {item state: reset predefined state} -body {
    .t collapse 8
    .t item state 8
} -result {enabled}

test tree-6.71 {item state: reset predefined state} -body {
    .t expand 8
    .t item state 8
} -result {open enabled}

test tree-6.72 {item state: reset predefined state} -body {
    .t toggle 8
    .t item state 8
} -result {enabled}

test tree-7.1 {marquee: missing args} -body {
    .t marquee
} -returnCodes error -result {wrong # args: should be ".t marquee command ?arg arg...?"}

test tree-7.2 {marquee: unknown command} -body {
    .t marquee foo
} -returnCodes error -result {bad command "foo": must be anchor, cget, configure, coords, corner, identify, or visible}

test tree-7.3 {marquee anchor: not yet modified} -body {
    .t marquee anchor
} -result {0 0}

test tree-7.4 {marquee anchor: odd arguments} -body {
    .t marquee anchor 1
} -returnCodes error -result {wrong # args: should be ".t marquee anchor ?x y?"}

test tree-7.5 {marquee identify: should be empty} -body {
    .t marquee identify
} -result {}

test tree-7.6 {marquee anchor: set it} -body {
    .t marquee anchor 5 5
} -result {}

test tree-7.7 {marquee coords: retrieve them} -body {
    .t marquee coords
} -result {5 5 0 0}

test tree-7.8 {marquee identify: just the root} -body {
    .t marquee identify
} -result {0}

test tree-7.9 {marquee corner: set it} -body {
    .t marquee corner 600 600
    .t marquee coords
} -result {5 5 600 600}

test tree-7.10 {marquee identify} -body {
    .t marquee identify
} -result {0 {1 0} 2 3 4 5 6 7 {8 {0 eRect eImage}}}

test tree-7.11 {marquee visible} -body {
    list [.t marquee configure -visible] \
	 [.t marquee visible 1] \
	 [.t marquee cget -visible] \
	 [.t marquee visible 0] \
	 [.t marquee cget -visible] \
	 [.t marquee configure -visible 1] \
	 [.t marquee visible]
} -result {{-visible {} {} 0 0} 1 1 0 0 {} 1}

test tree-8.1 {selection: missing args} -body {
    .t selection
} -returnCodes error -result {wrong # args: should be ".t selection command ?arg arg...?"}

test tree-8.2 {selection: unknown command} -body {
    .t selection foo
} -returnCodes error -result {bad command "foo": must be add, anchor, clear, count, get, includes, or modify}

test tree-8.3 {selection count/get: nothing selected yet} -body {
    list [.t selection count] [.t selection get]
} -result {0 {}}

test tree-8.4 {selection anchor: always defined} -body {
    .t selection anchor
} -result {0}

test tree-8.5 {selection anchor: modifies the anchor item} -body {
    .t selection anchor "root lastchild"
    .t index anchor
} -result {8}

test tree-8.6 {selection count/get: still nothing selected} -body {
    list [.t selection count] [.t selection get]
} -result {0 {}}

test tree-8.7 {selection add: all children of an item} -body {
    .t selection add "1 firstchild" "1 lastchild"
    list [.t selection count] [.t selection get]
} -result {2 {2 3}}

test tree-8.8 {selection add: all items and then some} -body {
    .t selection add all "1 lastchild"
    list [.t selection count] [.t selection get]
} -result {10 {0 1 2 3 4 5 6 7 8 12}}

test tree-8.9 {selection clear} -body {
    .t selection add all
    .t selection clear "root firstchild"
    list [.t selection count] [.t selection get]
} -result {9 {0 2 3 4 5 6 7 8 12}}

test tree-8.10 {selection clear: some items and then all} -body {
    .t selection clear "root lastchild" all
    list [.t selection count] [.t selection get]
} -result {0 {}}

test tree-8.11 {selection modify: to be or not to be?} -body {
    .t selection modify all all
    list [.t selection count] [.t selection get]
} -result {10 {0 1 2 3 4 5 6 7 8 12}}

test tree-8.12 {selection clear: totally empty} -body {
    .t selection clear
    list [.t selection count] [.t selection get]
} -result {0 {}}

test tree-8.12 {selection modify: to be or not to be?} -body {
    .t selection modify {{root firstchild} {root lastchild}} {{root lastchild}}
    list [.t selection count] [.t selection get]
} -result {2 {1 8}}

test tree-8.13 {selection includes: missing args} -body {
    .t selection includes
} -returnCodes error -result {wrong # args: should be ".t selection includes index"}

test tree-8.14 {selection includes: invalid item} -body {
    .t selection includes {foo bar}
} -returnCodes error -result {bad item description "foo bar"}

test tree-8.15 {selection includes: item is selected} -body {
    .t selection includes {root child 2}
} -result {1}

test tree-8.16 {selection includes: item is not selected} -body {
    .t selection includes {root child 0 firstchild}
} -result {0}

test tree-9.1 {see: missing args} -body {
    .t see
} -returnCodes error -result {wrong # args: should be ".t see item"}

test tree-9.2 {see: too many args} -body {
    .t see foo bar
} -returnCodes error -result {wrong # args: should be ".t see item"}

test tree-9.3 {see: invalid item} -body {
    .t see foo
} -returnCodes error -result {bad item description "foo"}

test tree-9.4 {see: bottom most item} -body {
    .t see "root bottom"
} -result {}

test tree-10.1 {range: missing args} -body {
    .t range
} -returnCodes error -result {wrong # args: should be ".t range first last"}

test tree-10.2 {range: too many args} -body {
    .t range foo bar baz
} -returnCodes error -result {wrong # args: should be ".t range first last"}

test tree-10.3 {range: select all from top to bottom} -body {
    .t range "root top" "root bottom"
} -result {0 1 2 3 4 5 6 7 8}

test tree-10.4 {range: select all from bottom to top} -body {
    .t range "root bottom" "root top"
} -result {0 1 2 3 4 5 6 7 8}

test tree-11.1 {orphans: too many args} -body {
    .t orphans foo
} -returnCodes error -result {wrong # args: should be ".t orphans"}

test tree-11.2 {orphans: 12 from above} -body {
    .t orphans
} -result {12}

test tree-11.3 {orphans: no orphans} -body {
    .t item lastchild 0 12
    .t orphans
} -result {}

test tree-12.1 {numitems: too many args} -body {
    .t numitems foo
} -returnCodes error -result {wrong # args: should be ".t numitems"}

test tree-12.2 {numitems} -body {
    .t numitems
} -result {10}

test tree-12.3 {numitems: simple double check with range} -body {
    expr {[.t numitems] == [llength [.t range first last]]}
} -result {1}

test tree-12.4 {contentbox: too many args} -body {
    .t contentbox foo
} -returnCodes error -result {wrong # args: should be ".t contentbox"}

test tree-12.5 {contentbox} -body {
    .t contentbox
} -result {3 3 203 203}

test tree-12.6 {contentbox: simple double check with borders} -body {
    expr {[lindex [.t contentbox] 0] \
		== ([.t cget -bd]+[.t cget -highlightthickness])}
} -result {1}

test tree-12.99 {element delete while item is still displayed} -body {
    .t element create elText text -text hallo
    .t style create stText
    .t style element stText elText
    set new [.t item create]
    .t item style set $new 0 stText
    .t item lastchild 0 $new
    .t element delete elText
    place [frame .obscure] -in .t -relwidth 1.0 -relheight 1.0
    update
    destroy .obscure
    update
} -result {}

test tree-13.1 {depth: too many args} -body {
    .t depth foo bar
} -returnCodes error -result {wrong # args: should be ".t depth ?item?"}

test tree-13.2 {depth of the root item} -body {
    .t depth root
} -result {0}

test tree-13.3 {depth of a deeper item} -body {
    .t depth "root firstchild lastchild"
} -result {2}

test tree-13.4 {depth of the tree} -body {
    .t depth
} -result {3}

test tree-13.5 {depth of the tree} -body {
    .t depth
} -setup {
    set rootKids [.t item children root]
    foreach i $rootKids {.t item remove $i}
} -cleanup {
    foreach i $rootKids {.t item lastchild root $i}
} -result {0}

test tree-14.1 {column: missing args} -body {
    .t column
} -returnCodes error -result {wrong # args: should be ".t column command ?arg arg...?"}

test tree-14.2 {column: unknown command} -body {
    .t column foo
} -returnCodes error -result {bad command "foo": must be bbox, cget, configure, delete, index, move, neededwidth, or width}

test tree-14.3 {column bbox: missing args} -body {
    .t column bbox
} -returnCodes error -result {wrong # args: should be ".t column bbox column"}

test tree-14.4 {column bbox: invalid column} -body {
    .t column bbox foo
} -returnCodes error -result {column with tag "foo" doesn't exist}

test tree-14.5 {column bbox: tree doesn't show headers} -body {
    .t configure -showheader 0
    .t column bbox column0
} -result {}

test tree-14.6 {column bbox} -body {
    .t configure -showheader 1
    .t column bbox 0
} -result {3 3 501 7}

test tree-14.7 {column bbox: tail column not allowed} -body {
    .t column bbox tail
} -returnCodes error -result {can't specify "tail" for this command}

test tree-14.8 {column configure: missing args} -body {
    .t column configure
} -returnCodes error -result {wrong # args: should be ".t column configure column ?option? ?value?"}

test tree-14.9 {column configure: invalid column} -body {
    .t column configure foo
} -returnCodes error -result {column with tag "foo" doesn't exist}

test tree-14.10 {column configure: list all options} -body {
    .t column configure column1
} -result {{-arrow {} {} none none} {-arrowside {} {} right right} {-arrowgravity {} {} left left} {-arrowpadw {} {} 6 6} {-arrowpade {} {} 6 6} {-bitmap {} {} {} {}} {-background {} {} #d9d9d9 #d9d9d9} {-borderwidth {} {} 2 2} {-button {} {} 1 1} {-expand {} {} 0 0} {-font {} {} {} {}} {-image {} {} {} {}} {-imagepade {} {} 6 6} {-imagepadw {} {} 6 6} {-itembackground {} {} {} {}} {-justify {} {} left left} {-minwidth {} {} {} {}} {-relief {} {} raised raised} {-stepwidth {} {} {} {}} {-sunken {} {} 0 0} {-tag {} {} {} column1} {-text {} {} {} {}} {-textcolor {} {} Black Black} {-textpade {} {} 6 6} {-textpadw {} {} 6 6} {-width {} {} {} {}} {-visible {} {} 1 1} {-widthhack {} {} 0 0}}

test tree-14.10 {column configure: list all options} -body {
    .t column configure column1
} -result {{-arrow {} {} none none} {-arrowside {} {} right right} {-arrowgravity {} {} left left} {-arrowpadw {} {} 6 6} {-arrowpade {} {} 6 6} {-bitmap {} {} {} {}} {-background {} {} #d9d9d9 #d9d9d9} {-borderwidth {} {} 2 2} {-button {} {} 1 1} {-expand {} {} 0 0} {-font {} {} {} {}} {-image {} {} {} {}} {-imagepade {} {} 6 6} {-imagepadw {} {} 6 6} {-itembackground {} {} {} {}} {-justify {} {} left left} {-minwidth {} {} {} {}} {-relief {} {} raised raised} {-stepwidth {} {} {} {}} {-sunken {} {} 0 0} {-tag {} {} {} column1} {-text {} {} {} {}} {-textcolor {} {} Black Black} {-textpade {} {} 6 6} {-textpadw {} {} 6 6} {-width {} {} {} {}} {-visible {} {} 1 1} {-widthhack {} {} 0 0}}

test tree-14.11 {column configure: tail column} -body {
    .t column configure tail
} -result {{-arrow {} {} none none} {-arrowside {} {} right right} {-arrowgravity {} {} left left} {-arrowpadw {} {} 6 6} {-arrowpade {} {} 6 6} {-bitmap {} {} {} {}} {-background {} {} #d9d9d9 #d9d9d9} {-borderwidth {} {} 2 2} {-button {} {} 1 1} {-expand {} {} 0 0} {-font {} {} {} {}} {-image {} {} {} {}} {-imagepade {} {} 6 6} {-imagepadw {} {} 6 6} {-itembackground {} {} {} {}} {-justify {} {} left left} {-minwidth {} {} {} {}} {-relief {} {} raised raised} {-stepwidth {} {} {} {}} {-sunken {} {} 0 0} {-tag {} {} {} {}} {-text {} {} {} {}} {-textcolor {} {} Black Black} {-textpade {} {} 6 6} {-textpadw {} {} 6 6} {-width {} {} {} {}} {-visible {} {} 1 1} {-widthhack {} {} 0 0}}

test tree-14.12 {column configure: invalid -arrow} -body {
    .t column configure column1 -arrow straight
} -returnCodes error -result {bad arrow "straight": must be none, up, or down}

test tree-14.13 {column configure/cget: -arrow} -body {
    .t column configure column1 -arrow up
    .t column cget column1 -arrow
} -result {up}

test tree-14.14 {column configure: invalid -arrowside} -body {
    .t column configure column1 -arrowside up
} -returnCodes error -result {bad arrowside "up": must be left or right}

test tree-14.15 {column configure/cget: -arrowside} -body {
    .t column configure column1 -arrowside left
    .t column cget column1 -arrowside
} -result {left}

test tree-14.16 {column configure: invalid -arrowgravity} -body {
    .t column configure column1 -arrowgravity both
} -returnCodes error -result {bad arrowgravity "both": must be left or right}

test tree-14.17 {column configure/cget: -arrowgravity} -body {
    .t column configure column1 -arrowgravity right
    .t column cget column1 -arrowgravity
} -result {right}

test tree-14.18 {column configure: invalid -arrowpadw} -body {
    .t column configure column1 -arrowpadw x
} -returnCodes error -result {bad screen distance "x"}

test tree-14.19 {column configure/cget: -arrowpadw/e} -body {
    .t column configure column1 -arrowpadw 8 -arrowpade 5
    list [.t column cget column1 -arrowpadw] \
	 [.t column cget column1 -arrowpade]
} -result {8 5}

test tree-14.20 {column configure: invalid -bitmap} -body {
    .t column configure column1 -bitmap foo
} -returnCodes error -result {bitmap "foo" not defined}

test tree-14.21 {column configure/cget: -bitmap} -body {
    .t column configure column1 -bitmap questhead
    .t column cget column1 -bitmap
} -result {questhead}

test tree-14.22 {column configure: invalid -background} -body {
    .t column configure column1 -background foo
} -returnCodes error -result {unknown color name "foo"}

test tree-14.23 {column configure/cget: -background} -body {
    .t column configure column1 -background magenta
    .t column cget column1 -background
} -result {magenta}

test tree-14.24 {column configure: invalid -borderwidth} -body {
    .t column configure column1 -borderwidth x
} -returnCodes error -result {bad screen distance "x"}

test tree-14.25 {column configure/cget: -borderwidth} -body {
    .t column configure column1 -borderwidth 4
    .t column cget column1 -borderwidth
} -result {4}

test tree-14.26 {column configure: invalid -button} -body {
    .t column configure column1 -button ""
} -returnCodes error -result {expected boolean value but got ""}

test tree-14.27 {column configure/cget: -button} -body {
    .t column configure column1 -button off
    .t column cget column1 -button
} -result {0}

test tree-14.28 {column configure: invalid -expand} -body {
    .t column configure column1 -expand ew
} -returnCodes error -result {expected boolean value but got "ew"}

test tree-14.29 {column configure/cget: -expand} -body {
    .t column configure column1 -expand true
    .t column cget column1 -expand
} -result {1}

test tree-14.30 {column configure: invalid -image} -body {
    .t column configure column1 -image questhead
} -returnCodes error -result {image "questhead" doesn't exist}

test tree-14.31 {column configure/cget: -image} -body {
    .t column configure column1 -image emptyImg
    .t column cget column1 -image
} -result {emptyImg}

test tree-14.32 {column configure: invalid -imagepade} -body {
    .t column configure column1 -imagepade y
} -returnCodes error -result {bad screen distance "y"}

test tree-14.33 {column configure/cget: -imagepadw/e} -body {
    .t column configure column1 -imagepadw 9 -imagepade 4
    list [.t column cget column1 -imagepadw] \
	 [.t column cget column1 -imagepade]
} -result {9 4}

test tree-14.34 {column configure: invalid -itembackground} -body {
    .t column configure column1 -itembackground no
} -returnCodes error -result {unknown color name "no"}

test tree-14.35 {column configure/cget: simple -itembackground} -body {
    .t column configure column1 -itembackground blue
    .t column cget column1 -itembackground
} -result {blue}

test tree-14.36 {column configure: invalid -itembackground list} -body {
    .t column configure column1 -itembackground {blue selected green active}
} -returnCodes error -result {unknown color name "selected"}

test tree-14.37 {column configure/cget: -itembackground list} -body {
    .t column configure column1 -itembackground {blue green magenta red}
    .t column cget column1 -itembackground
} -result {blue green magenta red}

test tree-14.38 {column configure: invalid -justify} -body {
    .t column configure column1 -justify no
} -returnCodes error -result {bad justification "no": must be left, right, or center}

test tree-14.39 {column configure/cget: simple -justify} -body {
    .t column configure column1 -justify center
    .t column cget column1 -justify
} -result {center}

test tree-14.40 {column configure: invalid -minwidth} -body {
    .t column configure column1 -minwidth z
} -returnCodes error -result {bad screen distance "z"}

test tree-14.41 {column configure/cget: -minwidth} -body {
    .t column configure column1 -minwidth 25
    .t column cget column1 -minwidth
} -result {25}

test tree-14.42 {column configure: invalid -relief} -body {
    .t column configure column1 -relief yes
} -returnCodes error -result {bad relief "yes": must be flat, groove, raised, ridge, solid, or sunken}

test tree-14.43 {column configure/cget: -relief} -body {
    .t column configure column1 -relief sunken
    .t column cget column1 -relief
} -result {sunken}

test tree-14.44 {column configure: invalid -stepwidth} -body {
    .t column configure column1 -stepwidth "\t"
} -returnCodes error -result {bad screen distance "	"}

test tree-14.45 {column configure/cget: -stepwidth} -body {
    .t column configure column1 -stepwidth 125
    .t column cget column1 -stepwidth
} -result {125}

test tree-14.46 {column configure: invalid -sunken} -body {
    .t column configure column1 -sunken groove
} -returnCodes error -result {expected boolean value but got "groove"}

test tree-14.47 {column configure/cget: -sunken} -body {
    .t column configure column1 -sunken on
    .t column cget column1 -sunken
} -result {1}

test tree-14.48 {column configure: -text} -body {
    .t column configure column1 -text "Text above Column 1"
    .t column cget column1 -text
} -result {Text above Column 1}

test tree-14.49 {column configure: invalid -textpadw} -body {
    .t column configure column1 -textpadw baz
} -returnCodes error -result {bad screen distance "baz"}

test tree-14.50 {column configure/cget: -textpadw/e} -body {
    .t column configure column1 -textpadw 8 -textpade 5
    list [.t column cget column1 -textpadw] \
	 [.t column cget column1 -textpade]
} -result {8 5}

test tree-14.51 {column configure: invalid -width} -body {
    .t column configure column1 -width all
} -returnCodes error -result {bad screen distance "all"}

test tree-14.52 {column configure/cget: -width} -body {
    .t column configure column1 -width 250
    .t column cget column1 -width
} -result {250}

test tree-14.53 {column configure: invalid -visible} -body {
    .t column configure column1 -visible never
} -returnCodes error -result {expected boolean value but got "never"}

test tree-14.54 {column configure/cget: -visible} -body {
    .t column configure column1 -visible no
    .t column cget column1 -visible
} -result {0}

test tree-14.55 {column configure: invalid -widthhack} -body {
    .t column configure column1 -widthhack ok
} -returnCodes error -result {expected boolean value but got "ok"}

test tree-14.56 {column configure/cget: -widthhack} -body {
    .t column configure column1 -widthhack yes
    .t column cget column1 -widthhack
} -result {1}

test tree-14.57 {column configure: -tag} -body {
    .t column configure column1 -tag column2
    .t column cget column1 -tag
} -returnCodes error -result {column with tag "column1" doesn't exist}

test tree-14.58 {column configure: -tag} -body {
    .t column cget column2 -tag
} -result {column2}

test tree-14.59 {column cget: -tag of tail} -body {
    # I think this should return tail...
    .t column cget tail -tag
} -result {}

test tree-14.60 {column configure/cget: -tag of tail} -body {
    # I think this should be forbidden...
    .t column configure tail -tag head
    .t column cget tail -tag
} -result {head}

test tree-14.61 {column cget: specify tail by its tag} -body {
    .t column cget head -tag
} -returnCodes error -result {column with tag "head" doesn't exist}

test tree-14.62 {column delete: missing args} -body {
    .t column delete
} -returnCodes error -result {wrong # args: should be ".t column delete column"}

test tree-14.63 {column delete: column tail} -body {
    .t column delete tail
} -returnCodes error -result {can't specify "tail" for this command}

test tree-14.64 {column delete: first column} -body {
    .t column delete 0
} -result {}

test tree-14.65 {suprise, surprise: column 0 still exists} -body {
    .t column cget 0 -tag
} -result {column2}

test tree-14.66 {column index: missing args} -body {
    .t column index
} -returnCodes error -result {wrong # args: should be ".t column index column"}

test tree-14.67 {column index: the easy case} -body {
    .t column index 0
} -result {0}

test tree-14.68 {column index} -body {
    .t column index column2
} -result {0}

test tree-14.69 {column index: tail column} -body {
    .t column index tail
} -result {1}

test tree-14.70 {column move: missing args} -body {
    .t column move
} -returnCodes error -result {wrong # args: should be ".t column move column before"}

test tree-14.71 {column move: invalid column} -body {
    .t column move 0 2
} -returnCodes error -result {bad column index "2": must be from 0 to 0}

test tree-14.72 {column move: invalid column} -body {
    .t column configure 1 -tag column1
    .t column configure 2 -tag column3
    .t column move 0 2
    .t column index column2
} -result {1}

test tree-14.73 {correct moved?} -body {
    set res {}
    for {set x 0} {$x < [.t numcolumns]} {incr x} {
	lappend res [.t column cget $x -tag]
    }
    set res
} -result {column1 column2 column3}

test tree-14.74 {column move: tail to the left} -body {
    .t column move tail 0
} -returnCodes error -result {can't specify "tail" for this command}

test tree-14.75 {column move: tail as before is ok} -body {
    .t column move 0 tail
    .t column index column1
} -result {2}

test tree-14.76 {column width: missing args} -body {
    .t column width
} -returnCodes error -result {wrong # args: should be ".t column width column"}

test tree-14.77 {column width: invalid column} -body {
    .t column width foo
} -returnCodes error -result {column with tag "foo" doesn't exist}

test tree-14.78 {column width: tail column returns always 0} -body {
    .t column width tail
} -result {0}

test tree-14.79 {column width} -body {
    .t element create eText2 text -font {{courier -12}} -text "Hello World"
    .t style create testStyle3
    .t style elements testStyle3 eText2
    .t item style set 1 column1 testStyle3
    update idletasks
    .t column width column1
} -result {136}

test tree-14.80 {column neededwidth: missing args} -body {
    .t column neededwidth
} -returnCodes error -result {wrong # args: should be ".t column neededwidth column"}

test tree-14.81 {column neededwidth: invalid column} -body {
    .t column neededwidth foo
} -returnCodes error -result {column with tag "foo" doesn't exist}

test tree-14.82 {column neededwidth: tail column returns always 0} -body {
    .t column neededwidth tail
} -result {0}

test tree-14.83 {column neededwidth} -body {
    .t column neededwidth column1
} -result {136}

test tree-15.1 {identify: missing args} -body {
    .t identify
} -returnCodes error -result {wrong # args: should be ".t identify x y"}

test tree-15.2 {identify: negative coords} -body {
    .t configure -showheader 1 -showlines 1 -showbuttons 1 \
	-borderwidth 2 -highlightthickness 1 -treecolumn 2 \
	-itemheight 0 -linethickness 1
    .t item hasbutton 1 true
    update idletasks
    .t identify -5 -5
} -result {}

test tree-15.3 {identify: header left} -body {
    .t identify 4 4
} -result {header 2 left}

test tree-15.4 {identify: header} -body {
    .t identify 40 4
} -result {header 2}

test tree-15.5 {identify: header right} -body {
    .t identify 190 4
} -result {header 2}

test tree-15.6 {identify: tail left} -body {
    .t identify 200 4
} -result {header tail left}

test tree-15.7 {identify: tail} -body {
    .t identify 250 4
} -result {header tail}

test tree-15.8 {identify: item (to the left)} -body {
    .t identify 4 10
} -result {item 1}

test tree-15.9 {identify: button} -body {
    .t identify 120 10
} -result {item 1 button}

test tree-15.10 {identify: over element} -body {
    .t identify 150 10
} -result {item 1 column 2 elem eText2}

test tree-15.11 {identify: item (to the right)} -body {
    # first make column wider, otherwise we can't get right of the item
    .t column configure column1 -width 250
    update idletasks 
    .t identify 210 10
} -result {item 1 column 2}

test tree-16.1 {dragimage: missing args} -body {
    .t dragimage
} -returnCodes error -result {wrong # args: should be ".t dragimage command ?arg arg...?"}

test tree-16.2 {dragimage: unknown command} -body {
    .t dragimage foo
} -returnCodes error -result {bad command "foo": must be add, cget, clear, configure, offset, or visible}

test tree-16.3 {dragimage configure} -body {
    .t dragimage configure
} -result {{-visible {} {} 0 0}}

test tree-16.4 {dragimage configure -visible} -body {
    .t dragimage configure -visible
} -result {-visible {} {} 0 0}

test tree-16.5 {dragimage cget -visible} -body {
    .t dragimage cget -visible
} -result {0}

test tree-16.6 {dragimage offset: without preceding add} -body {
    .t dragimage offset
} -result {0 0}

test tree-16.7 {dragimage add: invalid item} -body {
    .t dragimage add foo
} -returnCodes error -result {bad item description "foo"}

test tree-16.8 {dragimage add: invalid column} -body {
    .t dragimage add 1 foo
} -returnCodes error -result {column with tag "foo" doesn't exist}

test tree-16.9 {dragimage add: invalid element} -body {
    .t dragimage add 1 2 foo
} -returnCodes error -result {element "foo" doesn't exist}

test tree-16.10 {dragimage add: is still not visible} -body {
    .t dragimage add 1 2
    .t dragimage visible
} -result {0}

test tree-16.11 {dragimage visible} -body {
    .t dragimage visible 1
    .t dragimage cget -visible
} -result {1}

test tree-16.12 {dragimage offset} -body {
    .t dragimage offset 10 10
    .t dragimage offset
} -result {10 10}

test tree-16.13 {dragimage clear: too many args} -body {
    .t dragimage clear 1
} -returnCodes error -result {wrong # args: should be ".t dragimage clear"}

test tree-16.14 {dragimage clear: doesn't modify the offset} -body {
    .t dragimage clear
    .t dragimage offset
} -result {10 10}

test tree-17.1 {notify: missing args} -body {
    .t notify
} -returnCodes error -result {wrong # args: should be ".t notify command ?arg arg...?"}

test tree-17.2 {notify: unknown command} -body {
    .t notify foo
} -returnCodes error -result {bad command "foo": must be bind, configure, detailnames, eventnames, generate, install, linkage, or uninstall}

test tree-17.3 {notify bind: too much args} -body {
    .t notify bind z y z z y
} -returnCodes error -result {wrong # args: should be ".t notify bind ?object? ?pattern? ?script?"}

test tree-17.4 {notify configure: missing args} -body {
    .t notify configure
} -returnCodes error -result {wrong # args: should be ".t notify configure window pattern ?option? ?value? ?option value ...?"}

test tree-17.5 {notify detailnames: missing args} -body {
    .t notify detailnames
} -returnCodes error -result {wrong # args: should be ".t notify detailnames eventName"}

test tree-17.6 {notify eventnames: too much args} -body {
    .t notify eventnames Open
} -returnCodes error -result {wrong # args: should be ".t notify eventnames"}

test tree-17.7 {notify generate: missing args} -body {
    .t notify generate
} -returnCodes error -result {wrong # args: should be ".t notify generate pattern ?field value ...?"}

test tree-17.8 {notify install: missing args} -body {
    .t notify install
} -returnCodes error -result {wrong # args: should be ".t notify install option arg ..."}

test tree-17.9 {notify linkage: missing args} -body {
    .t notify linkage
} -returnCodes error -result {wrong # args: should be ".t notify linkage event ?detail?"}

test tree-17.10 {notify uninstall: missing args} -body {
    .t notify uninstall
} -returnCodes error -result {wrong # args: should be ".t notify uninstall option arg ..."}

# cleanup
image delete emptyImg
::tcltest::cleanupTests
return
